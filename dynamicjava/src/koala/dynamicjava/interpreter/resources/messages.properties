ambiguous.method = \
Multiple methods in %0 with name '%1' accept arguments (%3)
ambiguous.method.poly = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)
ambiguous.method.expected  = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
ambiguous.method.poly.expected = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
ambiguous.method.candidates = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Arguments: (%3)\n\
\    Matching methods: %5
ambiguous.method.poly.candidates = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Matching methods: %5
ambiguous.method.expected.candidates = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Matching methods: %5
ambiguous.method.poly.expected.candidates = \
Multiple methods in %0 with name '%1' match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Matching methods: %5

no.such.method = \
No method in %0 with name '%1' accepts arguments (%3)
no.such.method.name = \
No method in %0 has name '%1'
no.such.method.poly = \
No method in %0 with name '%1' matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)
no.such.method.expected  = \
No method in %0 with name '%1' matches this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
no.such.method.poly.expected = \
No method in %0 with name '%1' matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
no.such.method.candidates = \
No method in %0 with name '%1' matches this invocation\n\
\    Arguments: (%3)\n\
\    Candidate signatures: %5
no.such.method.poly.candidates = \
No method in %0 with name '%1' matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Candidate signatures: %5
no.such.method.expected.candidates = \
No method in %0 with name '%1' matches this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Candidate signatures: %5
no.such.method.poly.expected.candidates = \
No method in %0 with name '%1' matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Candidate signatures: %5

ambiguous.constructor = \
Multiple constructors in %0 accept arguments (%3)
ambiguous.constructor.poly = \
Multiple constructors in %0 match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)
ambiguous.constructor.expected  = \
Multiple constructors in %0 match this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
ambiguous.constructor.poly.expected = \
Multiple constructors in %0 match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
ambiguous.constructor.candidates = \
Multiple constructors in %0 match this invocation\n\
\    Arguments: (%3)\n\
\    Matching constructors: %5
ambiguous.constructor.poly.candidates = \
Multiple constructors in %0 match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Matching constructors: %5
ambiguous.constructor.expected.candidates = \
Multiple constructors in %0 match this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Matching constructors: %5
ambiguous.constructor.poly.expected.candidates = \
Multiple constructors in %0 match this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Matching constructors: %5

no.such.constructor = \
No constructor in %0 accepts arguments (%3)
no.such.constructor.poly = \
No constructor in %0 matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)
no.such.constructor.expected  = \
No constructor in %0 matches this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
no.such.constructor.poly.expected = \
No constructor in %0 matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4
no.such.constructor.candidates = \
No constructor in %0 matches this invocation\n\
\    Arguments: (%3)\n\
\    Candidate signatures: %5
no.such.constructor.poly.candidates = \
No constructor in %0 matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Candidate signatures: %5
no.such.constructor.expected.candidates = \
No constructor in %0 matches this invocation\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Candidate signatures: %5
no.such.constructor.poly.expected.candidates = \
No constructor in %0 matches this invocation\n\
\    Type arguments: <%2>\n\
\    Arguments: (%3)\n\
\    Expected return type: %4\n\
\    Candidate signatures: %5

ambiguous.name             = The name '%0' is ambiguous
ambiguous.inner.class      = Multiple classes in %0 have name '%1'
ambiguous.field            = Multiple fields in %0 have name '%1'

no.such.field              = No field in %0 has name '%1'
no.such.static.field       = No static field in %0 has name '%1'
no.such.inner.class        = No class in %0 has name '%1'


# Used by ClassInfoCompiler
abstract.method.body       = The abstract method '%0' must not have a body

# Used by ClassInfoCompiler
addition.type              = Bad type in addition

allocation.type            = Cannot construct a %0: a concrete class is required
inner.allocation           = Cannot construct a %0: an enclosing object of type %1 is required
static.inner.allocation    = Class '%0' is a static member of type %1


# Used by TypeChecker
array.dimension.type       = Bad array dimension expression type

# Used by TypeChecker
array.index.type           = Bad array index expression type

array.initializer.type     = Array initializer must be assigned to an array type

# Used by ClassInfoCompiler, TypeChecker
array.required             = '%0' is not an array

# Used by TypeChecker
assertion.fail.type        = Bad type in assertion failure message

# Used by TypeChecker, CompleteTypeSystem
assignment.types           = Bad types in assignment: from %0 to %1

# Used by ClassInfoCompiler, TypeChecker
bitwise.expression.type    = Bad type in bitwise expression

# Used by TypeChecker
boolean.expression.type    = Bad type in boolean expression

# Used by EvaluationVisitor
cannot.modify              = Variable '%0' cannot be modified

# Used by CompleteTypeSystem
cast.types                 = Bad types in cast: from %0 to %1

# Used by TypeChecker
catch.type                 = Bad 'catch' parameter type: %0 is not a Throwable

# Used by TypeChecker
compare.type               = Illegal comparison: cannot compare a %0 to a %1

# Used by TypeChecker
complement.expression.type = Bad type in complement expression

# Used by TypeChecker
condition.type             = Condition must be boolean

# Used by ClassInfoCompiler
conditional.type           = Bad types in conditional expression

constructor.call           = Constructor call not allowed here
inaccessible.super.call    = Cannot access the matching private constructor for type %0

# Used by ClassInfoCompiler
constructor.name           = Missing return type in the definition of the method '%0'

# Used by TypeChecker
duplicate.switch.case      = 'switch' contains multiple blocks for the same case

invalid.superclass         = Type %0 is not a valid superclass
invalid.superinterface     = Type %0 is not a valid superinterface
invalid.supertype          = Type %0 is not a valid supertype

# Used by ClassInfoCompiler, TypeChecker
increment.type             = Bad type in increment expression

# Used by TypeChecker
instanceof.type            = Bad type in instanceof expression

# Used by ClassInfoCompiler
interface.field.modifier   = Bad modifier for interface field '%0'

# Used by ClassInfoCompiler
interface.method.modifier  = Bad modifier for interface method '%0'
  
interface.member           = Illegal interface member

# Used by ClassInfoCompiler, TypeChecker
invalid.constant           = Invalid constant

invalid.enum.constant      = Invalid enum constant name
  
# Used by TypeChecker
iterable.type              = Iterated type must be an array or an Iterable
  
# Used by ClassInfoCompiler, TypeChecker
left.expression            = Malformed left expression in assignment

# Used by ClassInfoCompiler
left.operand               = Malformed left operand

# Used by TypeChecker
lock.type                  = Lock object must be of a reference type

# Used by ClassInfoCompiler
malformed.argument         = Malformed argument

# Used by ClassInfoCompiler
malformed.expression       = Malformed expression

# Used by ClassInfoCompiler
malformed.second.operand   = Malformed first choice in conditional expression

# Used by ClassInfoCompiler
malformed.third.operand    = Malformed second choice in conditional expression

malformed.type             = Type has incompatible bounds

# Used by ClassInfoCompiler
missing.method.body        = The body of the method '%0' is missing

# Used by ClassInfoCompiler
misplaced.abstract         = The class '%0' contains abstract members and must be declared abstract

# Used by ImportationManager, NameVisitor
no.such.member             = No member of %0 has name '%1'

# Used by TypeChecker
not.expression.type        = Bad type in logical not expression

# Used by StaticContext
not.implemented            = Feature not yet implemented

# Used by ClassInfoCompiler, TypeChecker, CompleteTypeSystem
numeric.expression.type    = Bad type in numeric expression

# Used by CompleteTypeSystem
primitive.type             = A primitive type is required

# Used by CompleteTypeSystem
reference.type             = A reference type is required

# Used by EvaluationVisitor
reflection.constructor.access = Unable to access the requested constructor of class '%1'

# Used by EvaluationVisitor
reflection.field.access    = Unable to access the field '%1' in class '%2'

# Used by EvaluationVisitor
reflection.method.access   = Unable to access the method '%1' in class '%2'

# Used by TypeChecker
reifiable.type             = A reifiable (non-parameterized, non-variable) type is required
  
return.not.allowed         = A 'return' statement is not allowed here
return.type                = Bad return type: given %0, expected %1
  
# Used by ClassInfoCompiler
right.operand              = Malformed right operand in expression

# Used by TypeChecker
selector.type              = Bad 'switch' selector type: %0

# Used by ClassInfoCompiler, TypeChecker
shift.expression.type      = Bad type in shift expression

# Used by TypeChecker
super.undefined            = 'super' is undefined in this context

# Used by TypeChecker
switch.label.type          = Bad 'switch' label type: %0

# Used by ClassInfoCompiler, TypeChecker
this.undefined             = 'this' is undefined in this context

# Used by TypeChecker
throw.type                 = Cannot throw a %0

type.argument              = Type arguments are invalid  

# Used by CompleteTypeSystem
type.argument.arity        = Incorrect number of type arguments

# Used by CompleteTypeSystem
type.argument.lower.bound  = Type argument %0 is not within its lower bound, %1

# Used by CompleteTypeSystem
type.argument.upper.bound  = Type argument %0 is not within its upper bound, %1

# Used by ThrownException  
uncaught.exception         = Uncaught exception of type %0

# Used by ClassInfoCompiler, ImportationManager, TypeChecker
undefined.class            = Undefined class '%0'

# Used by NameVisitor
undefined.name             = Undefined name '%0'
undefined.name.noinfo      = Undefined name

# Used by TreeCompiler
undefined.or.defined.class = Class '%0' not found or already defined

# Used by EvaluationVisitor
uninitialized.variable     = Variable '%0' uninitialized

# Used by NameVisitor
variable.redefinition      = Redefinition of '%0' 
  
wildcard.bound             = Invalid wildcard bound, %0
wildcard.bounds            = Invalid wildcard bounds, %0 and %1

# Used by TreeClass
class.cannot.access.superclass = Class '%0' cannot access its superclass '%1'. Make sure '%1' is a public class.
class.cannot.access.superinterface = Class '%0' cannot access its superinterface '%1'. Make sure '%1' is a public interface.
