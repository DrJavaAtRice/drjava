/* -*- Java -*- */
// Parser options
//
options {
  JAVA_UNICODE_ESCAPE    = true;
  STATIC                 = false;
  JDK_VERSION            = "1.5";
}

PARSER_BEGIN(Parser)
package koala.dynamicjava.parser.impl;

import java.util.*;
import java.io.File;

import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.tuple.Pair;
import edu.rice.cs.plt.collect.ConsList;
import edu.rice.cs.plt.collect.CollectUtil;

import koala.dynamicjava.parser.wrapper.*;
import koala.dynamicjava.tree.*;
import koala.dynamicjava.tree.ModifierSet.Modifier;
import koala.dynamicjava.tree.visitor.*;
import koala.dynamicjava.util.*;
import koala.dynamicjava.tree.tiger.*;

/**
 * This class represents a (interpreted) Java 1.1 language parser
 * adapted for 1.5 language extensions.
 */

public class Parser {
  /**
   * The name of the file currently interpreted; null by default
   */
  private File file = null;
  
  /**
   * A flag to use in semantic lookaheads.  Declared here as a workaround because 
   * lookahead can't access local variables or production parameters.
   */
  private boolean lookaheadFlag;

  /** Hack to pass the fact that a formal parameter was varargs back to the method/constructor production. */  
  boolean lastFormalParameterIsVarArgs = false;
  
  /**
   * The message reader
   */
  private LocalizedMessageReader reader =
    new LocalizedMessageReader("koala.dynamicjava.parser.resources.messages");
  
  /** Sets the current file */
  public void setFile(File f) { file = f; }
  
  private SourceInfo _range(Token first, Token last) {
    return SourceInfo.range(file, first.beginLine, first.beginColumn, last.endLine, last.endColumn);
  }
  
  private SourceInfo _range(Token first, SourceInfo.Wrapper last) {
    return SourceInfo.prepend(first.beginLine, first.beginColumn, last);
  }
  
  private SourceInfo _range(SourceInfo.Wrapper first, Token last) {
    return SourceInfo.extend(first, last.beginLine, last.beginColumn);
  }
  
  private SourceInfo _range(Token first, SourceInfo last) {
    return SourceInfo.prepend(first.beginLine, first.beginColumn, last);
  }
  
  private SourceInfo _range(SourceInfo first, Token last) {
    return SourceInfo.extend(first, last.beginLine, last.beginColumn);
  }
  
  private SourceInfo _range(SourceInfo.Wrapper first, SourceInfo.Wrapper last) {
    return SourceInfo.span(first, last);
  }
  
  private SourceInfo _range(SourceInfo first, SourceInfo last) {
    return SourceInfo.span(first, last);
  }
  
  /**
   * Throws a parse exception with the given message at the current (last consumed) token
   * @param message - the message to be thrown
   */
  
  private <T> T _throwParseException(String message) throws ParseException {
    ParseException pe = new ParseException(message);
    pe.currentToken = token;
    throw pe;
  }
  
  /**
   * Throws a parse exception with the given message at the current token, if the given
   * parse exception was one auto generated by the parser (not one of ours), but not if the
   * message is an <EOF> message, which is passed up to allow continuation of typing
   * @param pe - the previous parse exception thrown
   * @param message - the message to be thrown
   */
  private <T> T _throwParseException(ParseException pe, String message) throws ParseException {
    if (pe.expectedTokenSequences == null) { // has custom message
      message = pe.getMessage();
    }
    if(pe.getMessage().indexOf("<EOF>\"") != -1) {
      message = "Encountered Unexpected \"<EOF>\"";
    }
    return this.<T>_throwParseException(message);
  }
  
  private static enum DeclType { TOP, CLASS_MEMBER, INTERFACE_MEMBER, LOCAL, REPL };
  
  /**
   * Creates a field declaration
   */
  private FieldDeclaration createFieldDeclaration(ModifierSet  mods,
                                                  TypeName     typ,
                                                  Token        name,
                                                  Expression   exp,
                                                  int          dim) {
    SourceInfo si = (exp == null) ? _range(mods, name) : _range(mods, exp);

    // If the field is an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }
    
    return new FieldDeclaration(mods, typ, name.image, exp, si);
  }
  
  /**
   * Creates a variable declaration
   */
  private VariableDeclaration createVariableDeclaration(ModifierSet  mods,
                                                        TypeName     typ,
                                                        Token        name,
                                                        Expression   exp,
                                                        int          dim) {
    SourceInfo si = (exp == null) ? _range(mods, name) : _range(mods, exp);
    
    // If the variable contains an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }
    
    return new VariableDeclaration(mods, typ, name.image, exp, si);
  }
  

  private void checkModifiers(ModifierSet mods, ModifierSet.Modifier... allowed) throws ParseException {
    Set<ModifierSet.Modifier> copy = EnumSet.copyOf(mods.getFlags());
    for (ModifierSet.Modifier m : allowed) { copy.remove(m); }
    if (!copy.isEmpty()) {
      ModifierSet.Modifier badMod = copy.iterator().next();
      _throwParseException("Modifier " + badMod.getName() + " is not allowed here");
    }
  }
  
  
  /** A hierarchy of helper classes for building primary expressions. */
  abstract class Primary implements SourceInfo.Wrapper {
    private final SourceInfo _si;
    protected Primary(SourceInfo si) { _si = si; }
    public SourceInfo getSourceInfo() { return _si; }
    
    public Expression asExpression() throws ParseException {
      return _throwParseException("Incomplete expression");
    }
    public Primary dotId(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected identifier"); }
      else { return _throwParseException("Unexpected type arguments and identifier"); }
    }
    public Primary dotThis(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'this' keyword"); }
      else { return _throwParseException("Unexpected type arguments and 'this' keyword"); }
    }
    public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'super' keyword"); }
      else { return _throwParseException("Unexpected type arguments and 'super' keyword"); }
    }
    public Primary dotClass(Token t) throws ParseException {
      return _throwParseException("Illegal class literal");
    }
    public Primary dotNew(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'new' keyword"); }
      else { return _throwParseException("Unexpected 'new' keyword and type arguments"); }
    }
    public Primary withArrayDim(Token last) throws ParseException {
      return _throwParseException("Unexpected empty array brackets");
    }
    public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return _throwParseException("Unexpected array access");
    }
    public Primary withTypeArgs(List<TypeName> targs, Token last) throws ParseException {
      return _throwParseException("Unexpected type arguments");
    }
    public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      return _throwParseException("Unexpected argument list");
    }
    public Primary withClassBody(List<Node> members, Token last) throws ParseException {
      return _throwParseException("Unexpected class body");
    }
  }
  
  /** A primary that can be parsed as a complete expression and act as a method receiver, etc. */
  abstract class CompletedPrimary extends Primary {
    protected CompletedPrimary(SourceInfo si) { super(si); }
    
    @Override public abstract Expression asExpression() throws ParseException;
    
    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return new ObjectFieldAccessPrimary(asExpression(), id); }
      else { return new PartialObjectMethodCallPrimary(asExpression(), targs, id); }
    }
    
    @Override public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      return new PartialSuperConstructorCallPrimary(asExpression(), targs, t);
    }
    
    @Override public Primary dotNew(Option<List<TypeName>> targs, Token id) throws ParseException {
      return new PartialInnerAllocationPrimary(asExpression(), targs, id);
    }
    
    @Override public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return new ExpressionPrimary(new ArrayAccess(asExpression(), exp, _range(this, last)));
    }
  }
  
  /** A primary that can *only* be parsed as the given expression, regardless of what follows. */
  class ExpressionPrimary extends CompletedPrimary {
    private Expression _exp;
    public ExpressionPrimary(Expression exp) { super(exp.getSourceInfo()); _exp = exp; }
    public Expression asExpression() { return _exp; }
  }
  
  /** Like an ExpressionPrimary, but constructor calls can't be followed by additional dots, etc. */
  class ConstructorCallPrimary extends Primary {
    private ConstructorCall _call;
    public ConstructorCallPrimary(ConstructorCall call) { super(call.getSourceInfo()); _call = call; }
    @Override public Expression asExpression() { return _call; }
  }
  
  /** An ExpressionPrimary, but doesn't allow array accesses. */
  class ArrayAllocationPrimary extends ExpressionPrimary {
    public ArrayAllocationPrimary(ArrayAllocation alloc) { super(alloc); }
    public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return _throwParseException("Unexpected array access");
    }
  }
  
  
  /** A dotted sequence of names. */
  class AmbiguousNamePrimary extends CompletedPrimary {
    private final ConsList.Nonempty<IdentifierToken> _reversed;
    public AmbiguousNamePrimary(Token id) {
      this(ConsList.<IdentifierToken>singleton(new TreeToken(id, file)), _range(id, id));
    }
    private AmbiguousNamePrimary(ConsList.Nonempty<IdentifierToken> reversed, SourceInfo si) {
      super(si);
      _reversed = reversed;
    }
    private LinkedList<IdentifierToken> ids() { return CollectUtil.makeLinkedList(ConsList.reverse(_reversed)); }
    
    public Expression asExpression() {
      return new AmbiguousName(ids(), getSourceInfo());
    }
    
    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      if (targs.isNone()) {
        return new AmbiguousNamePrimary(ConsList.cons(new TreeToken(id, file), _reversed), _range(this, id));
      }
      else { return new PartialObjectMethodCallPrimary(asExpression(), targs, id); } 
    }
    
    @Override public Primary dotThis(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) {
        Option<String> cn = Option.some(TreeUtilities.listToName(ids()));
        return new ExpressionPrimary(new ThisExpression(cn, _range(this, t)));
      }
      else { return _throwParseException("Unexpected type arguments"); }
    }
    
    @Override public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return new PartialSuperPrimary(ids(), t); }
      else { return super.dotSuper(targs, t); }
    }
    
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(new ReferenceTypeName(ids(), getSourceInfo()), _range(this, t)));
    }
    
    @Override public Primary withArrayDim(Token last) {
      TypeName elt = new ReferenceTypeName(ids(), getSourceInfo());
      return new ArrayTypeNamePrimary(new ArrayTypeName(elt, 1, false, _range(this, last)));
    }
    
    @Override public Primary withTypeArgs(List<TypeName> targs, Token last) {
      return new GenericReferenceTypeNamePrimary(_reversed, targs, _range(this, last));
    }
    
    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last); 
      ConsList<? extends IdentifierToken> revObjIds = _reversed.rest();
      if (revObjIds.isEmpty()) {
        return new ExpressionPrimary(new SimpleMethodCall(_reversed.first().image(), args, si));
      }
      else {
        LinkedList<IdentifierToken> objIds = CollectUtil.makeLinkedList(ConsList.reverse(revObjIds));
        AmbiguousName obj = new AmbiguousName(objIds, _range(objIds.getFirst(), objIds.getLast()));
        return new ExpressionPrimary(new ObjectMethodCall(obj, _reversed.first().image(), args, si));
      }
    }
  }
  
  /** A dotted name with at least one type argument.  Can be followed by additional identifiers and type arguments. */
  class GenericReferenceTypeNamePrimary extends Primary {
    protected final ConsList.Nonempty<IdentifierToken> _reversed;
    protected final ConsList.Nonempty<List<TypeName>> _targsReversed;
    public GenericReferenceTypeNamePrimary(ConsList.Nonempty<IdentifierToken> reversed, List<TypeName> targs,
                                           SourceInfo si) {
      super(si);
      _reversed = reversed;
      ConsList<List<TypeName>> noArgs = ConsList.empty();
      int noArgCount = _reversed.size() - 1;
      for (int i = 0; i < noArgCount; i++) { noArgs = ConsList.cons(new LinkedList<TypeName>(), noArgs); }
      _targsReversed = ConsList.cons(targs, noArgs);
    }
    private GenericReferenceTypeNamePrimary(ConsList.Nonempty<IdentifierToken> reversed,
                                            ConsList.Nonempty<List<TypeName>> targsReversed, SourceInfo si) {
      super(si);
      _reversed = reversed;
      _targsReversed = targsReversed;
    }

    protected GenericReferenceTypeName asTypeName() {
      List<IdentifierToken> ids = CollectUtil.makeLinkedList(ConsList.reverse(_reversed));
      List<List<? extends TypeName>> targs =
          CollectUtil.<List<? extends TypeName>>makeLinkedList(ConsList.reverse(_targsReversed));
      return new GenericReferenceTypeName(ids, targs, getSourceInfo());
    }
    
    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      if (targs.isNone()) { return new IdGenericReferenceTypeNamePrimary(this, id); }
      else { return new PartialStaticMethodCallPrimary(asTypeName(), targs, id); }
    }

    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(asTypeName(), _range(this, t)));
    }

    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(asTypeName(), 1, false, _range(this, last)));
	}
    
  }
  
  /** A GenericReferenceTypeNamePrimary that ends with an id. */
  class IdGenericReferenceTypeNamePrimary extends GenericReferenceTypeNamePrimary {
    private final GenericReferenceTypeNamePrimary _prev;
    public IdGenericReferenceTypeNamePrimary(GenericReferenceTypeNamePrimary prev, Token id) {
      super(ConsList.cons(new TreeToken(id, file), prev._reversed),
            ConsList.cons(new LinkedList<TypeName>(), prev._targsReversed),
            _range(prev, id));
      _prev = prev;
    }
    @Override public Primary withTypeArgs(List<TypeName> targs, Token last) {
      ConsList.Nonempty<List<TypeName>> newTargs = ConsList.cons(targs, _targsReversed.rest());
      return new GenericReferenceTypeNamePrimary(_reversed, newTargs, _range(this, last));
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ExpressionPrimary(new StaticMethodCall(_prev.asTypeName(), _reversed.first().image(),
                                                        args, _range(this, last)));
    }
  }
  
  /** An array type name. */
  class ArrayTypeNamePrimary extends Primary {
    private final ArrayTypeName _type;
    public ArrayTypeNamePrimary(ArrayTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(_type, 1, false, _range(this, last)));
    }
  }
  
  /** A primitive type, which may be part of a class literal or an array type. */
  class PrimitiveTypeNamePrimary extends Primary {
    private final PrimitiveTypeName _type;
    public PrimitiveTypeNamePrimary(PrimitiveTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(_type, 1, false, _range(this, last)));
    }
  }
  
  /** A "void" keyword, which may be part of a class literal. */
  class VoidTypeNamePrimary extends Primary {
    private final VoidTypeName _type;
    public VoidTypeNamePrimary(VoidTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
  }
  

  /** Optional type arguments followed by a method name. */
  class PartialSimpleMethodCallPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialSimpleMethodCallPrimary(Option<List<TypeName>> targs, Token id, SourceInfo si) {
      super(si);
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) { return new ExpressionPrimary(new SimpleMethodCall(_name, args, si)); }
      else { return _throwParseException("Simple method calls with type arguments aren't yet implemented"); }
      // else { return new ExpressionPrimary(new PolymorphicSimpleMethodCall(_name, args, _targs, si)); }  
    }
  }
  
  /** An expression followed by a dot and a name.  May be followed by method arguments. */
  class ObjectFieldAccessPrimary extends CompletedPrimary {
    private final Expression _obj;
    private final String _name;
    public ObjectFieldAccessPrimary(Expression obj, Token id) {
      super(_range(obj, id));
      _obj = obj;
      _name = id.image;
    }
    public Expression asExpression() { return new ObjectFieldAccess(_obj, _name, getSourceInfo()); }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ExpressionPrimary(new ObjectMethodCall(_obj, _name, args, _range(this, last))); 
    }
  }
  
  /** An expression followed by a dot, optional type arguments, and a method name. */
  class PartialObjectMethodCallPrimary extends Primary {
    private final Expression _obj;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialObjectMethodCallPrimary(Expression obj, Option<List<TypeName>> targs, Token id) {
      super(_range(obj, id));
      _obj = obj;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) { return new ExpressionPrimary(new ObjectMethodCall(_obj, _name, args, si)); }
      else { return new ExpressionPrimary(new PolymorphicObjectMethodCall(_obj, _name, args, _targs.unwrap(), si)); }  
    }
  }

  /** A type followed by a dot, optional type arguments, and a method name. */
  class PartialStaticMethodCallPrimary extends Primary {
    private final TypeName _type;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    PartialStaticMethodCallPrimary(TypeName type, Option<List<TypeName>> targs, Token id) {
      super(_range(type, id));
      _type = type;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) { return new ExpressionPrimary(new StaticMethodCall(_type, _name, args, si)); }
      else { return new ExpressionPrimary(new PolymorphicStaticMethodCall(_type, _name, args, _targs.unwrap(), si)); }  
    }
  }
  
  /** The "this" keyword.  May be a constructor call. */
  class ThisExpressionPrimary extends CompletedPrimary {
    public ThisExpressionPrimary(Token t) { super(_range(t, t)); }
    public Expression asExpression() {
      return new ThisExpression(Option.<String>none(), getSourceInfo());
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ConstructorCallPrimary(new ConstructorCall(null, args, false, _range(this, last)));
    }
  }
  
  /** A "this" keyword prefixed by optional type arguments. */
  class PartialThisConstructorCallPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    public PartialThisConstructorCallPrimary(Option<List<TypeName>> targs, SourceInfo si) {
      super(si);
      _targs = targs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      if (_targs.isSome()) {
        return _throwParseException("Parameterized this constructor calls are not yet supported");
      }
      return new ConstructorCallPrimary(new ConstructorCall(null, args, false, _range(this, last)));
    }
  }
  
  /** The "super" keyword, optionally prefixed by a dotted name.  May be a constructor call or a field/method access. */
  class PartialSuperPrimary extends Primary {
    private final LinkedList<IdentifierToken> _ids; // may be null
    public PartialSuperPrimary(Token t) { super(_range(t, t)); _ids = null; }
    public PartialSuperPrimary(LinkedList<IdentifierToken> ids, Token t) {
      super(_range(ids.getFirst(), t));
      _ids = ids;
    }
    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      Option<String> cn = (_ids == null) ? Option.<String>none() : Option.some(TreeUtilities.listToName(_ids));
      if (targs.isNone()) { return new SuperFieldAccessPrimary(cn, id, _range(this, id)); }
      else { return new PartialSuperMethodCallPrimary(cn, targs, id, _range(this, id)); }
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      Expression outer = null;
      if (_ids != null) { outer = new AmbiguousName(_ids, _range(_ids.getFirst(), _ids.getLast())); }
      return new ConstructorCallPrimary(new ConstructorCall(outer, args, true, _range(this, last)));
    }
  }
  
  /** A "super" keyword prefixed by optional type arguments.  Optionally prefixed by an outer expression. */
  class PartialSuperConstructorCallPrimary extends Primary {
    private final Expression _outer; // may be null
    private final Option<List<TypeName>> _targs;
    public PartialSuperConstructorCallPrimary(Option<List<TypeName>> targs, SourceInfo si) {
      super(si);
      _outer = null;
      _targs = targs;
    }
    public PartialSuperConstructorCallPrimary(Expression outer, Option<List<TypeName>> targs, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      if (_targs.isSome()) {
        return _throwParseException("Parameterized super constructor calls are not yet supported");
      }
      return new ConstructorCallPrimary(new ConstructorCall(_outer, args, true, _range(this, last)));
    }
  }
  
  /**
   * A "super" keyword (optionally prefixed by a name), followed by a dot and a name.  May be followed by
   * method arguments.
   */
  class SuperFieldAccessPrimary extends CompletedPrimary {
    private final Option<String> _className;
    private final String _name;
    public SuperFieldAccessPrimary(Option<String> className, Token id, SourceInfo si) {
      super(si);
      _className = className;
      _name = id.image;
    }
    public Expression asExpression() throws ParseException {
      return new SuperFieldAccess(_className, _name, getSourceInfo());
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      return new ExpressionPrimary(new SuperMethodCall(_className, _name, args, _range(this, last))); 
    }
  }
  
  /**
   * A "super" keyword (optionally prefixed by a name), followed by a dot, optional type arguments, and
   * a method name.
   */
  class PartialSuperMethodCallPrimary extends Primary {
    private final Option<String> _className;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    PartialSuperMethodCallPrimary(Option<String> className, Option<List<TypeName>> targs, Token id,
                                  SourceInfo si) {
      super(si);
      _className = className;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) {
        return new ExpressionPrimary(new SuperMethodCall(_className, _name, args, si));
      }
      else {
        return new ExpressionPrimary(new PolymorphicSuperMethodCall(_className, _name, args, _targs.unwrap(), si));
      }  
    }
  }
  
  /** A "new" keyword followed by optional type arguments and a type. */
  class PartialSimpleAllocationPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    private final ReferenceTypeName _type;
    public PartialSimpleAllocationPrimary(Option<List<TypeName>> targs, ReferenceTypeName type, SourceInfo si) {
      super(si);
      _targs = targs;
      _type = type;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new SimpleAllocationPrimary(_targs, _type, args, _range(this, last));
    }
  }
  
  /**
   * A "new" keyword followed by optional type arguments, a type, and constructor arguments.  May
   * be an anonymous allocation if followed by a class body.
   */
  class SimpleAllocationPrimary extends CompletedPrimary {
    private final Option<List<TypeName>> _targs;
    private final ReferenceTypeName _type;
    private final List<Expression> _args;
    public SimpleAllocationPrimary(Option<List<TypeName>> targs, ReferenceTypeName type, List<Expression> args,
                                   SourceInfo si) {
      super(si);
      _targs = targs;
      _type = type;
      _args = args;
    }
    public Expression asExpression() {
      if (_targs.isNone()) { return new SimpleAllocation(_type, _args, getSourceInfo()); }
      else { return new PolymorphicSimpleAllocation(_type, _args, _targs.unwrap(), getSourceInfo()); }
    }
    @Override public Primary withClassBody(List<Node> members, Token last) {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) {
        return new ExpressionPrimary(new AnonymousAllocation(_type, _args, members, si));
      }
      else {
        return new ExpressionPrimary(new PolymorphicAnonymousAllocation(_type, _args, members, _targs.unwrap(), si));
      }
    }
  }
  
  /** An expression followed by a dot, "new", optional type arguments, and a class name. */
  class PartialInnerAllocationPrimary extends Primary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialInnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, Token id) {
      super(_range(outer, id));
      _outer = outer;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withTypeArgs(List<TypeName> args, Token last) {
      return new PartialGenericInnerAllocationPrimary(_outer, _targs, _name, args, last);
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new InnerAllocationPrimary(_outer, _targs, _name, Option.<List<TypeName>>none(), args, last);
    }
  }
  
  /** An expression followed by a dot, "new", optional type arguments, a class name, and class type arguments. */
  class PartialGenericInnerAllocationPrimary extends Primary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    private final List<TypeName> _ctargs;
    public PartialGenericInnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, String name,
                                                List<TypeName> ctargs, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
      _name = name;
      _ctargs = ctargs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new InnerAllocationPrimary(_outer, _targs, _name, Option.some(_ctargs), args, last);
    }
  }
  
  /**
   * An expresion followed by a dot, "new", optional type arguments, a class name, optional class type arguments,
   * and constructor arguments.  May be an anonymous allocation if followed by a class body.
   */
  class InnerAllocationPrimary extends CompletedPrimary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    private final Option<List<TypeName>> _ctargs;
    private final List<Expression> _args;
    public InnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, String name,
                                  Option<List<TypeName>> ctargs, List<Expression> args, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
      _name = name;
      _ctargs = ctargs;
      _args = args;
    }
    public Expression asExpression() {
      if (_targs.isNone()) {
        return new InnerAllocation(_outer, _name, _ctargs.unwrap(null), _args, getSourceInfo());
      }
      else {
        return new PolymorphicInnerAllocation(_outer, _name, _ctargs.unwrap(null), _args, _targs.unwrap(),
                                              getSourceInfo());
      }
    }
    @Override public Primary withClassBody(List<Node> members, Token last) {
      SourceInfo si = _range(this, last);
      if (_targs.isNone()) {
        return new ExpressionPrimary(new AnonymousInnerAllocation(_outer, _name, _ctargs.unwrap(null),
                                                                  _args, members, si));
      }
      else {
        return new ExpressionPrimary(new PolymorphicAnonymousInnerAllocation(_outer, _name, _ctargs.unwrap(null),
                                                                             _args, members, _targs.unwrap(), si));
      }
    }
  }
  
  
}

PARSER_END(Parser)
  
  
  
  /*
   * The lexical grammar
   */
  
  /* WHITE SPACE */
  
  SKIP :
{
  " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

/* COMMENTS */

  SKIP :
  {
    "//" : IN_SINGLE_LINE_COMMENT
      |
    "#" : IN_SINGLE_LINE_COMMENT
      |
    <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
      |
    "/*" : IN_MULTI_LINE_COMMENT
  }
  
  <IN_SINGLE_LINE_COMMENT>
  SKIP :
  {
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
  }
  
  <IN_FORMAL_COMMENT>
  SKIP :
  {
    <FORMAL_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    <MULTI_LINE_COMMENT: "*/" > : DEFAULT
  }
  
  <IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
  SKIP :
  {
    < ~[] >
  }
  
  /* RESERVED WORDS AND LITERALS */
  
  TOKEN :
  {
    < ABSTRACT: "abstract" >
    | < ASSERT: "assert" >
    | < BOOLEAN: "boolean" >
    | < BREAK: "break" >
    | < BYTE: "byte" >
    | < CASE: "case" >
    | < CATCH: "catch" >
    | < CHAR: "char" >
    | < CLASS: "class" >
    | < CONST: "const" >
    | < CONTINUE: "continue" >
    | < _DEFAULT: "default" >
    | < DO: "do" >
    | < DOUBLE: "double" >
    | < ELSE: "else" >
    | < ENUM: "enum" >
    | < EXTENDS: "extends" >
    | < FALSE: "false" >
    | < FINAL: "final" >
    | < FINALLY: "finally" >
    | < FLOAT: "float" >
    | < FOR: "for" >
    | < GOTO: "goto" >
    | < IF: "if" >
    | < IMPLEMENTS: "implements" >
    | < IMPORT: "import" >
    | < INSTANCEOF: "instanceof" >
    | < INT: "int" >
    | < INTERFACE: "interface" >
    | < LONG: "long" >
    | < NATIVE: "native" >
    | < NEW: "new" >
    | < NULL: "null" >
    | < PACKAGE: "package">
    | < PRIVATE: "private" >
    | < PROTECTED: "protected" >
    | < PUBLIC: "public" >
    | < RETURN: "return" >
    | < SHORT: "short" >
    | < STATIC: "static" >
    | < STRICTFP: "strictfp" >
    | < SUPER: "super" >
    | < SWITCH: "switch" >
    | < SYNCHRONIZED: "synchronized" >
    | < THIS: "this" >
    | < THROW: "throw" >
    | < THROWS: "throws" >
    | < TRANSIENT: "transient" >
    | < TRUE: "true" >
    | < TRY: "try" >
    | < VOID: "void" >
    | < VOLATILE: "volatile" >
    | < WHILE: "while" >
  }
  
  /* LITERALS */
  
  TOKEN :
  {
    < INTEGER_LITERAL:
      <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      >
      |
    < LONG_LITERAL:
      <DECIMAL_LITERAL> ["l","L"]
      | <HEX_LITERAL>     ["l","L"]
      | <OCTAL_LITERAL>   ["l","L"]
      >
      |
    < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
      |
    < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
      |
    < #OCTAL_LITERAL: "0" (["0"-"7"])* >
      |
    < FLOAT_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? ["f","F"]
      | "." (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      | (["0"-"9"])+ <EXPONENT> ["f","F"]
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
      >
      |
      < DOUBLE_LITERAL:
      (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
      >
      |
      < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
      |
      < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )
      "'"
      >
      |
      < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
         | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
                 | ["0"-"7"] ( ["0"-"7"] )?
                 | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                 )
              )
         )*
      "\""
      >
  }
  
  /* IDENTIFIERS */
  
  TOKEN :
  {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
      |
    < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
         ]
      >
      |
    < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
         ]
      >
  }
  
  /* SEPARATORS */
  
  TOKEN :
  {
    < LPAREN: "(" >
    | < RPAREN: ")" >
    | < LBRACE: "{" >
    | < RBRACE: "}" >
    | < LBRACKET: "[" >
    | < RBRACKET: "]" >
    | < SEMICOLON: ";" >
    | < COMMA: "," >
    | < DOT: "." >
  }
  
  /* OPERATORS */
  
  TOKEN :
  {
    < ASSIGN: "=" >
    | < GREATER_THAN: ">" >
    | < LESS: "<" >
    | < BANG: "!" >
    | < TILDE: "~" >
    | < HOOK: "?" >
    | < COLON: ":" >
    | < EQUAL: "==" >
    | < LESS_OR_EQUAL: "<=" >
    | < GREATER_OR_EQUAL: ">=" >
    | < NOT_EQUAL: "!=" >
    | < CONDITIONAL_OR: "||" >
    | < CONDITIONAL_AND: "&&" >
    | < INCREMENT: "++" >
    | < DECREMENT: "--" >
    | < PLUS: "+" >
    | < MINUS: "-" >
    | < STAR: "*" >
    | < SLASH: "/" >
    | < BITWISE_AND: "&" >
    | < BITWISE_OR: "|" >
    | < XOR: "^" >
    | < REMAINDER: "%" >
    | < LEFT_SHIFT: "<<" >
      /* | < RIGHT_SIGNED_SHIFT: ">>" >
       | < RIGHT_UNSIGNED_SHIFT: ">>>" > */
    | < PLUS_ASSIGN: "+=" >
    | < MINUS_ASSIGN: "-=" >
    | < STAR_ASSIGN: "*=" >
    | < SLASH_ASSIGN: "/=" >
    | < AND_ASSIGN: "&=" >
    | < OR_ASSIGN: "|=" >
    | < XOR_ASSIGN: "^=" >
    | < REMAINDER_ASSIGN: "%=" >
    | < LEFT_SHIFT_ASSIGN: "<<=" >
    | < RIGHT_SIGNED_SHIFT_ASSIGN: ">>=" >
    | < RIGHT_UNSIGNED_SHIFTASSIGN: ">>>=" >
    | < VAR_ARGS:  "...">
  }
  
  TOKEN : /* OPERATORS, from Generics Preprocessor  */
  {
    /*  < ASSIGN: "=" >
     | < GT: ">" >
     | < LT: "<" >
     | < BANG: "!" >
     | < TILDE: "~" >
     | < HOOK: "?" >
     | < COLON: ":" >
     | < EQ: "==" >
     | < LE: "<=" >
     | < GE: ">=" >
     | < NE: "!=" >
     | < SC_OR: "||" >
     | < SC_AND: "&&" >
     | < INCR: "++" >
     | < DECR: "--" >
     | < PLUS: "+" >
     | < MINUS: "-" >
     | < STAR: "*" >
     | < SLASH: "/" >
     | < BIT_AND: "&" >
     | < BIT_OR: "|" >
     | < XOR: "^" >
     | < REM: "%" >
     | < LSHIFT: "<<" >
     | */
    < RSIGNEDSHIFT: ">>" >
    {
      matchedToken.kind = RSSHIFT1;
      matchedToken.image = ">@1";
      matchedToken.next = new Token();
      matchedToken.next.kind = RSSHIFT2;
      matchedToken.next.image = ">@2";
    }
    | < RUNSIGNEDSHIFT: ">>>" >
    {
      matchedToken.image = ">`1";
      matchedToken.kind = RUSHIFT1;
      matchedToken.next = new Token();
      matchedToken.next.kind = RUSHIFT2;
      matchedToken.next.image = ">`2";
      matchedToken.next.next = new Token();
      matchedToken.next.next.kind = RUSHIFT3;
      matchedToken.next.next.image = ">`3";
    }
    | < RSSHIFT1: ">@1" >
    | < RSSHIFT2: ">@2" >
    | < RUSHIFT1: ">`1" >
    | < RUSHIFT2: ">`2" >
    | < RUSHIFT3: ">`3" >
      /*| < PLUSASSIGN: "+=" >
       | < MINUSASSIGN: "-=" >
       | < STARASSIGN: "*=" >
       | < SLASHASSIGN: "/=" >
       | < ANDASSIGN: "&=" >
       | < ORASSIGN: "|=" >
       | < XORASSIGN: "^=" >
       | < REMASSIGN: "%=" >
       | < LSHIFTASSIGN: "<<=" >
       | < RSIGNEDSHIFTASSIGN: ">>=" >
       | < RUNSIGNEDSHIFTASSIGN: ">>>=" >*/
  }
  
  JAVACODE
    void _errorChar(char c) {
    _throwParseException("'" + c + "' expected.");
  }
  /*
   * The syntactic grammar
   */
  
  // Productions for the intepreter ////////////////////////////////////////////////
  
  /**
   * Parses input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> parseStream() :
  { List<Node> list = new LinkedList<Node>(); List<Node> ns; }
  {
    try {
      (  ns = replStatement() { list.addAll(ns); } )* <EOF>
      { return list; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
  }
  
  /**
   * Parses an item of the input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (a list because a single variable declaration
   * can be parsed to multiple VariableDeclaration nodes)
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> replStatement() :
  { ModifierSet mods; Node node = null; List<Node> nodes = null; }
  {
    try {
      (
        LOOKAHEAD(2) node = keywordStatement(false) // lookahead distinguishes synchronized modifier from statement
      | mods = modifiers()
        (
          node = unmodifiedPackageDeclaration(mods, DeclType.REPL)
        | node = unmodifiedTypeDeclaration(mods, DeclType.REPL)
        | LOOKAHEAD(methodLookahead()) node = unmodifiedMethodDeclaration(mods, DeclType.REPL)
        | LOOKAHEAD(variableLookahead()) nodes = unmodifiedVariableDeclaration(mods, DeclType.REPL)
        )
      | mods = noModifiers()
        (
          node = unmodifiedPackageDeclaration(mods, DeclType.REPL)
        | node = importDeclaration()
        | node = unmodifiedTypeDeclaration(mods, DeclType.REPL)
        | LOOKAHEAD(methodLookahead()) node = unmodifiedMethodDeclaration(mods, DeclType.REPL)
        | LOOKAHEAD(variableLookahead()) nodes = unmodifiedVariableDeclaration(mods, DeclType.REPL)
        | node = nonKeywordStatement(false)
        )
      )
      { return (node != null) ? Collections.singletonList(node) : nodes; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
  }
  

  // Productions for Packages ////////////////////////////////////////////////////////
  
  /**
   * Parses a Java compilation unit
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  CompilationUnit parseCompilationUnit() :
  {
    ModifierSet mods;
    Token start = getToken(1);
    PackageDeclaration pkg = null;
    List<ImportDeclaration> imps = new LinkedList<ImportDeclaration>();
    ImportDeclaration imp;
    List<Node> decls = new LinkedList<Node>();
    Node decl;
  }
  {
    [
      (
        ( imp=importDeclaration() { imps.add(imp); } )+
      |   
        mods = optionalModifiers()
        (
          pkg=unmodifiedPackageDeclaration(mods, DeclType.TOP)
            ( imp=importDeclaration() { imps.add(imp); } )*
        |
          decl=unmodifiedTypeDeclaration(mods, DeclType.TOP) { decls.add(decl); }
        )
      )
      (
        decl=typeDeclaration(DeclType.TOP) { decls.add(decl); }
      | ";"
      )*
    ]
    <EOF>
    { return new CompilationUnit(pkg, imps, decls, _range(start, token)); }
  }
  
  ModifierSet optionalModifiers() :
  { ModifierSet mods = null; }
  {
    mods=modifiers() { return mods; }
  | mods=noModifiers() { return mods; }
  }
  
  /** Create an empty modifier set at the current location. */
  ModifierSet noModifiers() :
  {}
  {
    {
      SourceInfo si = SourceInfo.point(file, getToken(1).beginLine, getToken(1).beginColumn);
      return new ModifierSet(EnumSet.noneOf(Modifier.class), new LinkedList<Annotation>(), si);
    }
  }  
  
  /**
   * Parse a nonempty list of modifiers and annotations
   */
  ModifierSet modifiers() :
  {
    EnumSet<ModifierSet.Modifier> flags = EnumSet.noneOf(ModifierSet.Modifier.class);
    Annotation ann;
    List<Annotation> annots = new LinkedList<Annotation>();
    Token first = getToken(1);
  }
  {
    (
      "abstract"
      {
        if (flags.contains(Modifier.ABSTRACT)) {
          throw new ParseError(reader.getMessage("abstract.abstract", null), _range(token, token));
        }
        if (flags.contains(Modifier.FINAL)) {
          throw new ParseError(reader.getMessage("abstract.final", null), _range(token, token));
        }
        if (flags.contains(Modifier.NATIVE)) {
          throw new ParseError(reader.getMessage("abstract.native", null), _range(token, token));
        }
        flags.add(Modifier.ABSTRACT);
      }
    | 
      "final"
      {
        if (flags.contains(Modifier.FINAL)) {
          throw new ParseError(reader.getMessage("final.final", null), _range(token, token));
        }
        if (flags.contains(Modifier.ABSTRACT)) {
          throw new ParseError(reader.getMessage("abstract.final", null), _range(token, token));
        }
        flags.add(Modifier.FINAL);
      }
    | 
      "public"
      {
        if (flags.contains(Modifier.PUBLIC)) {
          throw new ParseError(reader.getMessage("public.public", null), _range(token, token));
        }
        if (flags.contains(Modifier.PROTECTED)) {
          throw new ParseError(reader.getMessage("public.protected", null), _range(token, token));
        }
        if (flags.contains(Modifier.PRIVATE)) {
          throw new ParseError(reader.getMessage("public.private", null), _range(token, token));
        }
        flags.add(Modifier.PUBLIC);
      }
    | 
      "protected"
      {
        if (flags.contains(Modifier.PROTECTED)) {
          throw new ParseError(reader.getMessage("protected.protected", null), _range(token, token));
        }
        if (flags.contains(Modifier.PUBLIC)) {
          throw new ParseError(reader.getMessage("public.protected", null), _range(token, token));
        }
        if (flags.contains(Modifier.PRIVATE)) {
          throw new ParseError(reader.getMessage("protected.private", null), _range(token, token));
        }
        flags.add(Modifier.PROTECTED);
      }
    | 
      "private"
      {
        if (flags.contains(Modifier.PRIVATE)) {
          throw new ParseError(reader.getMessage("private.private", null), _range(token, token));
        }
        if (flags.contains(Modifier.PUBLIC)) {
          throw new ParseError(reader.getMessage("public.private", null), _range(token, token));
        }
        if (flags.contains(Modifier.PROTECTED)) {
          throw new ParseError(reader.getMessage("protected.private", null), _range(token, token));
        }
        flags.add(Modifier.PRIVATE);
      }
    | 
      "transient"
      {
        if (flags.contains(Modifier.TRANSIENT)) {
          throw new ParseError(reader.getMessage("transient.transient", null), _range(token, token));
        }
        flags.add(Modifier.TRANSIENT);
      }
    | 
      "volatile"
      {
        if (flags.contains(Modifier.VOLATILE)) {
          throw new ParseError(reader.getMessage("volatile.volatile", null), _range(token, token));
        }
        flags.add(Modifier.VOLATILE);
      }
    | 
      "native"
      {
        if (flags.contains(Modifier.NATIVE)) {
          throw new ParseError(reader.getMessage("native.native", null), _range(token, token));
        }
        if (flags.contains(Modifier.ABSTRACT)) {
          throw new ParseError(reader.getMessage("abstract.native", null), _range(token, token));
        }
        flags.add(Modifier.NATIVE);
      }
    | 
      "static"
      {
        if (flags.contains(Modifier.STATIC)) {
          throw new ParseError(reader.getMessage("static.static", null), _range(token, token));
        }
        flags.add(Modifier.STATIC);
      }
    | 
      "synchronized"
      {
        if (flags.contains(Modifier.SYNCHRONIZED)) {
          throw new ParseError(reader.getMessage("synchronized.synchronized", null), _range(token, token));
        }
        flags.add(Modifier.SYNCHRONIZED);
      }
    | 
      "strictfp"
      {
        if (flags.contains(Modifier.STRICT)) {
          throw new ParseError(reader.getMessage("strictfp.strictfp", null), _range(token, token));
        }
        flags.add(Modifier.STRICT);
      }
    | 
      ann = annotation()
      { annots.add(ann); }
    )+
    { return new ModifierSet(flags, annots, _range(first, token)); }
  }
  
  PackageDeclaration packageDeclaration(DeclType level) :
  { ModifierSet mods; PackageDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedPackageDeclaration(mods, level) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid package declaration");
    }
  }
 

  PackageDeclaration unmodifiedPackageDeclaration(ModifierSet mods, DeclType level) :
  { ReferenceTypeName name = null; }
  {
    try {
      "package" [ name=referenceTypeName() ] (";" | <EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Package names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Empty package name");
        }
        checkModifiers(mods); // only annotations are allowed
        return new PackageDeclaration(mods, name.getRepresentation(), _range(mods, token));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid package declaration");
    }
  }
  

  ImportDeclaration importDeclaration() :
  {
    ReferenceTypeName name = null;
    Token star = null;
    Token t1, t2;
    Token sttic = null;
  }
  {
    try {
      t1="import" [sttic="static"] [name=referenceTypeName()] ["." star="*"] (t2=";" | t2=<EOF>)
      {
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Import names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Missing name - Cannot import");
        }
        return new ImportDeclaration(name.getRepresentation(), star != null, sttic != null, _range(t1, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid Import Declaration");
    }
  }
  

  TypeDeclaration typeDeclaration(DeclType level) :
  { ModifierSet mods; TypeDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedTypeDeclaration(mods, level) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid declaration");
    }
  }


  TypeDeclaration unmodifiedTypeDeclaration(ModifierSet mods, DeclType level) :
  { TypeDeclaration node; }
  {
    try {
      ( node=unmodifiedClassDeclaration(mods, level)
      | node=unmodifiedEnumDeclaration(mods, level)
      | node=unmodifiedInterfaceDeclaration(mods, level)
      )
      { return node; }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid declaration");
    }
  }
  
  // Productions for Names ////////////////////////////////////////////////////////
  
  /**
   * Parses a name
   * @return a list of tree token
   * @see koala.dynamicjava.parser.wrapper.TreeToken
   */
  List<IdentifierToken> name() :
  {
    Token id;
    List<IdentifierToken>  list = new LinkedList<IdentifierToken>();
  }
  {
    id=<IDENTIFIER>
    {
      list.add(new TreeToken(id, file));
    }
    ( LOOKAHEAD(2)
       "." id=<IDENTIFIER>
     {
      list.add(new TreeToken(id, file));
    }
    )*
    {
      return list;
    }
  }
  
  // Production for a ReferenceTypeName ////////////////////////////////////////////////////////

  /**
   * Consumes as large a name as possible: the type must not be followed by ".[id]" or "<", because
   * the parser will assume those delimiters mark a continuation of the ReferenceTypeName.
   */
  ReferenceTypeName referenceTypeName() :
  {
    Token id = null;
    LinkedList<IdentifierToken> ids = new LinkedList<IdentifierToken>();
    List<TypeName> targs = null;
    boolean parameterized = false;
    List<List<? extends TypeName>> allTypeArgs = new LinkedList<List<? extends TypeName>>();
  }
  {
    try{
      id=<IDENTIFIER>
        [ LOOKAHEAD(1) targs=typeArguments() ] // always consume type arguments if available
      {
        ids.add(new TreeToken(id, file));
        allTypeArgs.add((targs == null) ? new LinkedList<TypeName>() : targs);
        parameterized |= targs != null;
        targs = null;
      }
      ( LOOKAHEAD(2) "." id=<IDENTIFIER> // consume as large a name as possible
          [ LOOKAHEAD(1) targs=typeArguments() ] // always consume type arguments if available
          {
            ids.add(new TreeToken(id, file));
            allTypeArgs.add((targs == null) ? new LinkedList<TypeName>() : targs);
            parameterized |= targs != null;
            targs = null;
          }
      )*
        
      {
        SourceInfo si = _range(ids.getFirst(), token);
        if (parameterized) { return new GenericReferenceTypeName(ids, allTypeArgs, si); }
        else { return new ReferenceTypeName(ids, si); }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid reference name");
    }
  }
  
  /**
   * Parses a comma separated list of ReferenceTypeName names
   * @return a list of ReferenceTypeName
   * @see koala.dynamicjava.tree.ReferenceTypeName
   */
  List<? extends ReferenceTypeName> ReferenceTypeNameList() :
  {
    List<ReferenceTypeName> list = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName obj;
  }
  {
    obj=referenceTypeName() { list.add(obj); }
    ( "," obj=referenceTypeName() { list.add(obj); } )*
    { return list; }
  }
  
  // Productions for Classes //////////////////////////////////////////////////////
  
  // Productions for Class Declaration ============================================
  
  /**
   * Parses a class declaration
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration classDeclaration(DeclType level) :
  { ClassDeclaration cd; ModifierSet md; }
  {
    md=optionalModifiers() cd=unmodifiedClassDeclaration(md, level) { return cd; }
  }
  
  /**
   * Parses a class declaration without modifier
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  ClassDeclaration unmodifiedClassDeclaration(ModifierSet mods, DeclType level) :
  {
    Token t;
    Token id;
    TypeParameter[] typeParameters = null;
    ReferenceTypeName  ext  = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> body;
  }
  {
    t="class" id=<IDENTIFIER>
      [ typeParameters = typeParameters() ]
      [ "extends" ext=referenceTypeName() ] [ "implements" impl=ReferenceTypeNameList() ]
      body=classBody()
    {
      switch (level) {
        case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PROTECTED, Modifier.PRIVATE,
                                          Modifier.STATIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL,
                                              Modifier.ABSTRACT, Modifier.STRICT); break;
        case LOCAL: checkModifiers(mods, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
      }
      if (typeParameters != null) {
        return new GenericClassDeclaration(mods, id.image, ext, impl, body, typeParameters, _range(mods, token));
      }
      else {
        return new ClassDeclaration(mods, id.image, ext, impl, body, _range(mods, token));
      }
    }
  }
  
  /**
   * Used internally to parse the body of a class
   */
  List<Node> classBody() :
  {
    List<Node> list = new LinkedList<Node>();
    List<Node> decl;
  }
  {
    try {
      "{"
        ( decl=classBodyDeclaration() { list.addAll(decl); } )*
        "}"
      { return list; }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid class body");
    }
  }
  
  /**
   * Parses one declaration in the body of a class.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> classBodyDeclaration() :
  {
    ModifierSet mods;
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      LOOKAHEAD(2) node=initializer() { list.add(node); return list; }
    |
      ";" { return list; }
    |
      mods = optionalModifiers()
      (
        node = unmodifiedTypeDeclaration(mods, DeclType.CLASS_MEMBER)
      | LOOKAHEAD(constructorLookahead()) node = unmodifiedConstructorDeclaration(mods)
      | LOOKAHEAD(methodLookahead()) node = unmodifiedMethodDeclaration(mods, DeclType.CLASS_MEMBER)
      | LOOKAHEAD(variableLookahead()) list = unmodifiedVariableDeclaration(mods, DeclType.CLASS_MEMBER)
      )
      { if (node != null) { list.add(node); } return list; }
    }
    catch (ParseException pe) {
      _throwParseException(pe,"Invalid member declaration");
    }
  }
  
  
  // Productions for variable declaration ============================================
  
  /**
   * Parses a variable (field or local) declaration.
   * @return a list of field declaration because one variable declaration can
   *         contain multiple declarations.
   */
  List<Node> variableDeclaration(DeclType level) :
  { ModifierSet mods; List<Node> decls; }
  {
    try {
      mods = optionalModifiers() decls = unmodifiedVariableDeclaration(mods, level) { return decls; }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "Invalid variable declaration");
    }
  }
  
  
  List<Node> unmodifiedVariableDeclaration(ModifierSet mods, DeclType level) :
  {
    TypeName      typ;
    Token         id;
    int           dim  = 0;
    Expression    exp  = null;
    List<Node>    list = new LinkedList<Node>();
  }
  {
    try
    {
        typ=type() id=<IDENTIFIER>
        ( "[" "]" { dim++; } )*
          [ "=" exp=variableInitializer() ]
            {
              switch (level) {
                case CLASS_MEMBER:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED, Modifier.STATIC, 
                                 Modifier.FINAL, Modifier.VOLATILE, Modifier.TRANSIENT);
                  list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                  break;
                case INTERFACE_MEMBER:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
                  list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                  break;
                case REPL:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL);
                  list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                  break;
                default:
                  checkModifiers(mods, Modifier.FINAL);
                  list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                  break;
              }
            }
        ( "," { dim = 0; exp = null; }
         id=<IDENTIFIER>
         ( "[" "]" { dim++; } )*
         [ "=" exp=variableInitializer() ]
           {
             switch (level) {
               case CLASS_MEMBER:
               case INTERFACE_MEMBER:
                 list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                 break;
               default:
                 list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                 break;
             }
           }
        )*
        (
          ";"
        |
          {
            Token lookahead = getToken(1);
            if (!(level.equals(DeclType.REPL) &&
                  (lookahead.kind == ParserConstants.EOF || lookahead.image.equals("}")))) {
              _throwParseException("Invalid variable declaration");
            }
          }
        )
        { return list; }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "Invalid variable declaration");
    }
    
  }
  
  // Productions for Method Declaration ===========================================
  
  MethodDeclaration methodDeclaration(DeclType level) :
  { ModifierSet mods; MethodDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedMethodDeclaration(mods, level) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
  }
  
  MethodDeclaration unmodifiedMethodDeclaration(ModifierSet mods, DeclType level) :
  {
    TypeParameter[] typeParameters = null;
    TypeName typ;
    Token id;
    int dim = 0;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    BlockStatement body = null;
  }
  {
    try {
        [ typeParameters = typeParameters() ]
        typ=resultType()
        id=<IDENTIFIER>
        params=formalParameters()
        ( "[" "]" { dim++; } )*
          [ "throws" exceptions=ReferenceTypeNameList() ]
          (
            body=block()
          | ";"
          )
        {
          switch (level) {
            case CLASS_MEMBER:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED, Modifier.STATIC,
                             Modifier.FINAL, Modifier.ABSTRACT, Modifier.SYNCHRONIZED, Modifier.NATIVE,
                             Modifier.STRICT);
              break;
            case INTERFACE_MEMBER:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT);
              break;
            case REPL:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT);
              break;
            default:
              checkModifiers(mods, Modifier.STRICT);
              break;
          }
          if (lastFormalParameterIsVarArgs) mods.getFlags().add(Modifier.VARARGS);

          if (dim > 0) {
            typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
          }
          
          if (typeParameters == null) {
            return new MethodDeclaration(mods, typ, id.image, params, exceptions, body, _range(mods, token));
          }
          else {
            return new PolymorphicMethodDeclaration(mods, typ, id.image, params, exceptions, body, typeParameters,
                                                    _range(mods, token));
          }
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
  }
  
  /**
   * Parses formal parameters of the form '(param, param, ...)'
   * @see koala.dynamicjava.tree.FormalParameter
   */
  List<FormalParameter> formalParameters() :
  {
    List<FormalParameter> list = new LinkedList<FormalParameter>();
    FormalParameter node;
    FormalParameter lastParam = null;
  }
  {
    try
    {
      "(" { lastFormalParameterIsVarArgs = false; }
      [ node=formalParameter() { list.add(node); }
          (
            ","
            { if (lastFormalParameterIsVarArgs) _throwParseException("Varargs parameter must be last"); }
            node=formalParameter() { list.add(node); }
          )*
      ]
      ")"
      { return list; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameters");
    }
  }
  
  /**
   * Parses one formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  FormalParameter formalParameter() :
  {
    ModifierSet mods;
    TypeName  typ;
    Token id;
    Token varargs = null;
    int   dim = 0;
  }
  {
    try {
      mods=optionalModifiers() typ=type() [ varargs = <VAR_ARGS> ] id=<IDENTIFIER> ( "[" "]" { dim++; } )*
      {
        checkModifiers(mods, Modifier.FINAL);
        if (dim > 0) {
          typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
        }
        if (varargs != null) {
          lastFormalParameterIsVarArgs = true;
          typ = new ArrayTypeName(typ, 1, true, _range(typ, varargs));
        }
        return new FormalParameter(mods, typ, id.image, _range(mods, token));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid formal parameter");
    }
  }
  
  
  // Production for Initializer ===================================================
  
  /**
   * Parses one initializer
   * @see koala.dynamicjava.tree.Initializer
   */
  Initializer initializer() :
  {
    Token t = null;
    BlockStatement node;
  }
  {
    [ t="static" ] node=block()
    {
      if (t == null) {
        return new InstanceInitializer(node, node.getSourceInfo());
      } else {
        return new ClassInitializer(node, _range(t, node));
      }
    }
  }
  
  // Productions for Constructor Declaration ======================================
  
  ConstructorDeclaration constructorDeclaration() :
  { ModifierSet mods; ConstructorDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedConstructorDeclaration(mods) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
  }
  
  
  ConstructorDeclaration unmodifiedConstructorDeclaration(ModifierSet mods) :
  {
    TypeParameter[]   typeParameters = null;
    Token                 id;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    ConstructorCall ci = null;
    List<Node> stmt;
    LinkedList<Node> stmts = new LinkedList<Node>();
  }
  {
    try {
        [ typeParameters = typeParameters() ]
        id=<IDENTIFIER>
        params=formalParameters()
        [ "throws" exceptions=ReferenceTypeNameList() ]
        "{"
        ( stmt=blockStatement() { stmts.addAll(stmt); } )*
        "}"
        {
          // check for a constructor call ExpressionStatement
          if (!stmts.isEmpty()) {
            Node first = stmts.getFirst();
            if (first instanceof ExpressionStatement) {
              Expression exp = ((ExpressionStatement) first).getExpression();
              if (exp instanceof ConstructorCall) {
                ci = (ConstructorCall) exp;
                stmts.removeFirst();
              }
            }
          }
          checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED);
          if (lastFormalParameterIsVarArgs) mods.getFlags().add(Modifier.VARARGS);
          if (typeParameters == null) {
            return new ConstructorDeclaration(mods, id.image, params, exceptions, ci, stmts, _range(mods, token));
          } else {
            return new PolymorphicConstructorDeclaration(mods, id.image, params, exceptions, ci, stmts,
                                                         typeParameters, _range(mods, token));
          }
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
  }
  
  // Productions for Interfaces ///////////////////////////////////////////////////
  
  /**
   * Parses a interface declaration
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration interfaceDeclaration(DeclType level) :
  { ModifierSet mods; InterfaceDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedInterfaceDeclaration(mods, level) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
  }
  
  /**
   * Parses a interface declaration without modifier
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  InterfaceDeclaration unmodifiedInterfaceDeclaration(ModifierSet mods, DeclType level) :
  {
    Token id;
    TypeParameter[] typeParameters = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> list = new LinkedList<Node>();
    List<Node>  decl;
  }
  {
    try {
      "interface" id=<IDENTIFIER>
        [ typeParameters = typeParameters() ]
        [ "extends" impl=ReferenceTypeNameList() ]
        "{"
        ( decl=interfaceMemberDeclaration() { list.addAll(decl); } )*
        "}"
        {
          switch (level) {
            case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STRICT); break;
            case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED,
                                              Modifier.STATIC, Modifier.ABSTRACT, Modifier.STRICT); break;
            case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC,
                                                  Modifier.ABSTRACT, Modifier.STRICT); break;
            case LOCAL: checkModifiers(mods, Modifier.ABSTRACT, Modifier.STRICT); break;
            case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STRICT); break;
          }
      
        if (typeParameters == null) {
          return new InterfaceDeclaration(mods, id.image, impl, list, _range(mods, token));
        } else {
          return new GenericInterfaceDeclaration(mods, id.image, impl, list, typeParameters, _range(mods, token));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
  }
  
  /**
   * Parses one declaration in the body of an interface.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> interfaceMemberDeclaration() :
  {
    ModifierSet mods;
    Node node = null;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try
    {
      mods = optionalModifiers()
      (
        node = unmodifiedTypeDeclaration(mods, DeclType.INTERFACE_MEMBER)
      | LOOKAHEAD(methodLookahead()) node=unmodifiedMethodDeclaration(mods, DeclType.INTERFACE_MEMBER)
      | LOOKAHEAD(variableLookahead()) list=unmodifiedVariableDeclaration(mods, DeclType.INTERFACE_MEMBER)
      | ";"
      )
      {
        if (node != null) { list.add(node); }
        return list;
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid interface member declaration");
    }
  }
  
  // Productions for Enums ////////////////////////////////////////////////////////
  
  /**
   * Parses an enum declaration
   * @see koala.dynamicjava.tree.EnumDeclaration
   */
  EnumDeclaration enumDeclaration(DeclType level) :
  { ModifierSet mods; EnumDeclaration decl; }
  {
    try {
      mods = optionalModifiers() decl = unmodifiedEnumDeclaration(mods, level) { return decl; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid enum declaration");
    }
  }
  
  EnumDeclaration unmodifiedEnumDeclaration(ModifierSet mods, DeclType level) :
  {
    Token id;
    List<? extends ReferenceTypeName> impl = null;
    EnumDeclaration.EnumBody body;
  }
  {
    "enum"
      id=<IDENTIFIER>
      ["implements" impl=ReferenceTypeNameList()]
      "{"
      body = enumBody()
      "}"
    {
      switch (level) {
        case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT); break;
        case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PROTECTED, Modifier.PRIVATE,
                                          Modifier.STATIC, Modifier.STRICT); break;
        case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.STRICT); break;
        case LOCAL: checkModifiers(mods, Modifier.STRICT); break;
        case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT); break;
      }
      return new EnumDeclaration(mods, id.image, impl, body, _range(mods, token));
    }
  }
  
  /**
   * Parses the body of an enum
   * @see koala.dynamicjava.tree.Node
   */
  EnumDeclaration.EnumBody enumBody() :
  {
    List<EnumDeclaration.EnumConstant> consts = null;
    List<Node> decls = new LinkedList<Node>();
    List<Node> ns;
  }
  {
    [ consts = enumConstants() ]
    [";" ( ns = classBodyDeclaration() { decls.addAll(ns); } )* ]
    {
      return new EnumDeclaration.EnumBody((consts==null) ? new LinkedList<EnumDeclaration.EnumConstant>() : consts,
                                          decls);
    }
  }
  
  List<EnumDeclaration.EnumConstant> enumConstants() :
  {
    List<EnumDeclaration.EnumConstant> list = new LinkedList<EnumDeclaration.EnumConstant>();
    EnumDeclaration.EnumConstant c;
  }
  {
    c = enumConstant() { list.add(c); }
    ( LOOKAHEAD(2) "," c = enumConstant() { list.add(c); } )*
    [ "," ]
    { return list; }
  }
  
  EnumDeclaration.EnumConstant enumConstant() :
  {
    ModifierSet mods;
    Token id;
    List<Expression> args = null;
    List<Node> body = null;
  }
  {
    mods = optionalModifiers()
      id = <IDENTIFIER>
      [ args = arguments() ] // quite unnaturally, type parameters for polymorphic enum constructors (which are allowed) cannot be specified!!
      [ body = classBody() ]
      
    {
      checkModifiers(mods); // can only have annotations
      return new EnumDeclaration.EnumConstant(mods, id.image, args, body, _range(mods, token));
    }
  }
  
  
  // Productions for Arrays ////////////////////////////////////////////////////////
  
  /**
   * Parses an array initializer
   * @see koala.dynamicjava.tree.ArrayInitializer
   */
  ArrayInitializer arrayInitializer() :
  {
    Expression init;
    Token      t = null, b, e;
    List<Expression> list = new LinkedList<Expression>();
  }
  {
    b="{" [ init=variableInitializer()
             { list.add(init); }
           ( LOOKAHEAD(2)
              "," init=variableInitializer()
              { list.add(init); }
           )* ]
             [ t="," ] e="}"
           { return new ArrayInitializer(list, _range(b, e)); }
  }
  
  /**
   * Parses a variable initializer (ie. an expression or an array initializer)
   * @see koala.dynamicjava.tree.Expression
   */
  Expression variableInitializer() :
  {
    Expression exp;
  }
  {
    ( exp=arrayInitializer()
       | exp=expression() )
    {
      return exp;
    }
  }
  
  // Productions for Blocks And Statements ////////////////////////////////////////////
  
  /**
   * Parses a block
   * @see koala.dynamicjava.tree.BlockStatement
   */
  BlockStatement block() :
  {
    Token p1;
    Token p2;
    List<Node> nodes;
    List<Node> list = new LinkedList<Node>();
  }
  {
    try {
      p1="{"
        ( nodes=blockStatement()
           {
        list.addAll(nodes);
      }
      )*
        p2="}"
      {
        return new BlockStatement(list, _range(p1, p2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
  }
  
  /**
   * Parses one block statement.
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  List<Node> blockStatement() :
  { ModifierSet mods; Node node = null; List<Node> nodes = null; }
  {
    try {
      (
        LOOKAHEAD(2) node = keywordStatement(true) // lookahead distinguishes synchronized modifier from statement
      |
        mods = modifiers()
        (
          node = unmodifiedTypeDeclaration(mods, DeclType.LOCAL)
        | LOOKAHEAD(variableLookahead()) nodes = unmodifiedVariableDeclaration(mods, DeclType.LOCAL)
        )
      |
        mods = noModifiers()
        (
          node = unmodifiedTypeDeclaration(mods, DeclType.LOCAL)
        | LOOKAHEAD(variableLookahead()) nodes = unmodifiedVariableDeclaration(mods, DeclType.LOCAL)
        | node = nonKeywordStatement(true)
        )
      )
      { return (node != null) ? Collections.singletonList(node) : nodes; }
    }
    catch(ParseException pe) {
      _throwParseException(pe, "Invalid block statement");
    }
  }

  
  Node statement(boolean strictExpressions) :
  { Node node; }
  {
    node=keywordStatement(strictExpressions) { return node; }
  | node=nonKeywordStatement(strictExpressions) { return node; }
  }
  
  /** A statement that starts with a keyword or special delimiter. */
  Node keywordStatement(boolean strictExpressions) :
  { Node node; }
  {
    (
        node=block()
      | node=emptyStatement()
      | node=ifStatement()
      | node=assertStatement()
      | node=whileStatement()
      | node=doStatement()
      | node=switchStatement()
      | node=forStatement()
      | node=breakStatement()
      | node=continueStatement()
      | node=returnStatement()
      | node=throwStatement()
      | node=synchronizedStatement()
      | node=tryStatement()
    )
    { return node; }
  }
  
  /** A statement that does not begin with a keyword (and thus may need special lookahead treatment). */
  Node nonKeywordStatement(boolean strictExpressions) :
  { Node node; }
  {
    LOOKAHEAD(2) node=labeledStatement() { return node; }
  | node=expressionStatement(strictExpressions) { return node; }
  }
  
  /**
   * Parses a labeled statement
   * @see koala.dynamicjava.tree.ContinueTarget
   * @see koala.dynamicjava.tree.LabeledStatement
   */
  Statement labeledStatement() :
  {
    Token id;
    Node  node;
  }
  {
    id=<IDENTIFIER> ":" node=statement(true)
    {
      if (node instanceof ContinueTarget) {
        ((ContinueTarget)node).addLabel(id.image);
        return (Statement)node;
      } else {
        return new LabeledStatement(id.image, node, _range(id, node));
      }
    }
  }
  
  /**
   * Parses an empty statement
   * @see koala.dynamicjava.tree.EmptyStatement
   */
  EmptyStatement emptyStatement() :
  {
    Token t;
  }
  {
    t=";"
    {
      return new EmptyStatement(_range(t, t));
    }
  }
  
  /**
   * Parses an if statement
   * @see koala.dynamicjava.tree.IfThenStatement
   * @see koala.dynamicjava.tree.IfThenElseStatement
   */
  Statement ifStatement() :
  {
    Token t;
    Expression exp;
    Node       stat1;
    Node       stat2 = null;
  }
  {
    try {
      t="if" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat1=statement(true)
        [ LOOKAHEAD(1) "else" stat2=statement(true) ]
      {
        if (stat2 == null) {
          return new IfThenStatement(exp, stat1, _range(t, stat1));
        } else {
          return new IfThenElseStatement(exp, stat1, stat2, _range(t, stat2));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid if statement");
    }
  }
  
  
  /**
   * Parses an assert statement
   * @see koala.dynamicjava.tree.AssertStatement
   */
  AssertStatement assertStatement() :
  {
    Token t, t2;
    Expression exp, falseString = null;
  }
  {
    try { 
      t="assert" exp=expression() [":" falseString=expression()] (t2=";" | t2=<EOF>)
      {   
        return new AssertStatement(exp, falseString, _range(t, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid assert statement");
    }
  }
  
  
  /**
   * Parses a while statement
   * @see koala.dynamicjava.tree.WhileStatement
   */
  WhileStatement whileStatement() :
  {
    Token      t;
    Expression exp;
    Node       stat;
  }
  {
    
    try{
      t="while" ( "(" | _errorChar('('))
        exp=expression() ")"
        stat=statement(true)
      {
        return new WhileStatement(exp, stat, _range(t, stat));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid while statement");
    }
  }
  
  /**
   * Parses a do statement
   * @see koala.dynamicjava.tree.DoStatement
   */
  DoStatement doStatement() :
  {
    Token      t1, t2;
    Expression exp;
    Node       stat;
  }
  {
    try {
      t1="do" stat=statement(true) "while"
        ( "(" | _errorChar('('))
        exp=expression() ")" t2=";"
      {
        return new DoStatement(exp, stat, _range(t1, t2));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid do statement");
    }
  }
  
  /**
   * Parses a switch statement
   * @see koala.dynamicjava.tree.SwitchStatement
   */
  SwitchStatement switchStatement() :
  {
    Token b, e;
    Expression sel;
    SwitchBlock sb;
    List<SwitchBlock> cases = new LinkedList<SwitchBlock>();
  }
  {
    try {
      b="switch"
        ( "(" | _errorChar('('))
        sel=expression()
        ")"
        ( "{" | _errorChar('{'))
        ( sb = switchBlock() { cases.add(sb); } )*
        e="}"
        { return new SwitchStatement(sel, cases, _range(b, e)); }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid switch statement");
    }
  }
  
  SwitchBlock switchBlock() :
  {
    Token t, t2;
    Expression val = null;
    List<Node> stat;
    List<Node> allStats = new LinkedList<Node>();
    SourceInfo si;
  }
  {
    ( t="case" val=expression() | t="default" )
    ( t2 = ":" { si = _range(t, t2); } | _errorChar(':') { si = _range(t, t); } )
    (
      stat=blockStatement()
      {
        allStats.addAll(stat);
        if (stat.size() > 0)
          si = _range(si, stat.get(stat.size()-1).getSourceInfo());
      }
    )*
    {
      return new SwitchBlock(val, (allStats.isEmpty()) ? null: allStats, si);
    }
  }  
  
  /**
   * Parses a for statement (with standard or foreach syntax)
   * @see koala.dynamicjava.tree.ForStatement
   * Modified by Adam Wulf and David Peters
   * March 2004: Dr. Java team.
   * @see koala.dynamicjava.tree.ForSlashEachStatement
   * @see koala.dynamicjava.tree.ForEachStatement
   */
  ForSlashEachStatement forStatement() :
  {
    Token start;
    ModifierSet mods;
    FormalParameter param = null;
    List<Node> init = null;
    Expression exp = null;
    List<Node> update = null;
    Node stmt;
  }
  {
    try {
      start="for" ( "(" | _errorChar('('))
      (
        mods = modifiers()
        (
          LOOKAHEAD( forEachParameter(mods) ":" ) param = forEachParameter(mods) ":" exp = expression()
        | LOOKAHEAD( variableLookahead() ) init = unmodifiedVariableDeclaration(mods, DeclType.LOCAL)
        )
      | mods = noModifiers()
        (
          LOOKAHEAD( forEachParameter(mods) ":" ) param = forEachParameter(mods) ":" exp = expression()
        | LOOKAHEAD( variableLookahead() ) init = unmodifiedVariableDeclaration(mods, DeclType.LOCAL)
        | init = expressionStatementList() ";"
        | ";"
        )
      )
      [
        LOOKAHEAD({ param == null })
        [ exp = expression() ] ";"
        [ update = expressionStatementList() ]
      ]
      ")"
      stmt = statement(true)
      {
        if (param == null) {
          return new ForStatement(init, exp, update, stmt, _range(start, stmt));
        }
        else {
          return new ForEachStatement(param, exp, stmt, _range(start, stmt));
        }
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid for statement");
    }
  }
  
  /**
   * A for-each parameter, which is more restricted than a general formal parameter (no additional array 
   * brackets, and no varargs)
   */
  FormalParameter forEachParameter(ModifierSet mods) :
  { TypeName typ; Token id; Expression exp; }
  {
    typ=type() id=<IDENTIFIER>
      {
        checkModifiers(mods, Modifier.FINAL);
        return new FormalParameter(mods, typ, id.image, _range(mods, id));
      }
  }
  
  /**
   * Parses a comma separated list of strict ExpressionStatements
   */
  List<Node> expressionStatementList() :
  { List<Node> list = new LinkedList<Node>(); Expression exp; }
  {
    exp=statementExpression()
    {
      list.add(new ExpressionStatement(exp, true, exp.getSourceInfo()));
    }
    ( "," exp=statementExpression()
      {  list.add(new ExpressionStatement(exp, true, exp.getSourceInfo())); }
    )*
    { return list; }
  }
  
  /**
   * Parses a break statement
   * @see koala.dynamicjava.tree.BreakStatement
   */
  BreakStatement breakStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="break" [ id=<IDENTIFIER> ] e=";"
      {
        return new BreakStatement((id != null) ? id.image : null, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid break statement");
    }
  }
  
  /**
   * Parses a continue statement
   * @see koala.dynamicjava.tree.ContinueStatement
   */
  ContinueStatement continueStatement() :
  {
    Token b, e;
    Token id = null;
  }
  {
    try {
      b="continue" [ id=<IDENTIFIER> ] e=";"
      {
        return new ContinueStatement((id != null) ? id.image : null, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid continue statement");
    }
  }
  
  /**
   * Parses a return statement
   * @see koala.dynamicjava.tree.ReturnStatement
   */
  ReturnStatement returnStatement() :
  {
    Token b, e;
    Expression exp = null;
  }
  {
    try {
      b="return" [ exp=expression() ] e=";"
      {
        return new ReturnStatement(exp, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid return statement");
    }
  }
  
  /**
   * Parses a throw statement
   * @see koala.dynamicjava.tree.ThrowStatement
   */
  ThrowStatement throwStatement() :
  {
    Token b, e;
    Expression exp;
  }
  {
    try {
      b="throw" exp=expression() e=";"
      {
        return new ThrowStatement(exp, _range(b, e));
      }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid throw statement");
    }
  }
  
  /**
   * Parses a synchronized statement
   * @see koala.dynamicjava.tree.SynchronizedStatement
   */
  SynchronizedStatement synchronizedStatement() :
  {
    Token      t;
    Expression exp;
    Node       stmt;
  }
  {
    try {
      t="synchronized" ( "(" | _errorChar('('))
        exp=expression() ")" stmt=block()
        { return new SynchronizedStatement(exp, stmt, _range(t, stmt)); }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid synchronized statement");
    }
  }
  
  /**
   * Parses a try statement
   * @see koala.dynamicjava.tree.TryStatement
   */
  TryStatement tryStatement() :
  {
    Token           t, u;
    Node            tryBlock;
    Node            catchBlock;
    List<CatchStatement>      catches = new LinkedList<CatchStatement>();
    FormalParameter formal;
    Node            finallyBlock = null;
  }
  {
    try{
      t="try" tryBlock=block()
        (
          u="catch"
          ( "(" | _errorChar('('))
          formal=formalParameter()
          ")"
          catchBlock=block()
          { catches.add(new CatchStatement(formal, catchBlock, _range(u, catchBlock))); }
        )*
        [ "finally" finallyBlock=block() ]
        {
          if (finallyBlock == null && catches.size() == 0) {
            throw new ParseError(reader.getMessage("try.without.catch", null), _range(t, t));
          }
          return new TryStatement(tryBlock, catches, finallyBlock, _range(t, token));
        }
    }
    catch(ParseException pe) {
      _throwParseException(pe,"Invalid try statement");
    }
  }
  
  /**
   * Parses an ExpressionStatement; if strictExpression is true,
   * a trailing semicolon is required and only StatementExpressions
   * will be allowed.
   */
  ExpressionStatement expressionStatement(boolean strictExpression) :
  { Expression exp; Token t = null; }
  {
    { lookaheadFlag = strictExpression; } // makes strictExpression visible to lookahead
    (
        LOOKAHEAD({ lookaheadFlag }) exp = statementExpression() t = ";"
      | exp = expression() ( LOOKAHEAD(<EOF> | "}") {} | t = ";")
    )
    { return new ExpressionStatement(exp, t != null, _range(exp, token)); }
  }
  
  // Productions for Expressions /////////////////////////////////////////////////////////
  
  /**
   * Parses an expression
   * @see koala.dynamicjava.tree.Expression
   */
  Expression expression() :
  {
    Expression exp;
  }
  {
    exp=conditionalExpression() [ exp=expressionSuffix(exp) ]
    {
      return exp;
    }
  }
  
  /**
   * Parse only an expression that can appear as a statement
   */
  Expression statementExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3 = null;
  }
  {
    ( exp=preIncrementExpression()
       | exp=preDecrementExpression()
       | exp=primaryExpression()
       [ "++"
          { exp = new PostIncrement(exp, _range(exp, token)); }
        | "--"
          { exp = new PostDecrement(exp, _range(exp, token)); }
        | exp=expressionSuffix(exp)
       ]
    )
        {
          if (exp instanceof StatementExpression) {
            return exp;
          } else {
            throw new ParseError(reader.getMessage("expression.statement", null), exp.getSourceInfo());
          }
        }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression expressionSuffix(Expression pre) :
  {
    Expression exp2;
    Expression exp;
  }
  {
    ( "="    exp2=expression()
       {
      exp = new SimpleAssignExpression(pre, exp2, _range(pre, exp2));
    }
     | "*="   exp2=expression()
       {
       exp = new MultiplyAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "/="   exp2=expression()
       {
       exp = new DivideAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "%="   exp2=expression()
       {
       exp = new RemainderAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "+="   exp2=expression()
       {
       exp = new AddAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "-="   exp2=expression()
       {
       exp = new SubtractAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "<<="  exp2=expression()
       {
       exp = new ShiftLeftAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | ">>="  exp2=expression()
       {
       exp = new ShiftRightAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | ">>>=" exp2=expression()
       {
       exp = new UnsignedShiftRightAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "&="   exp2=expression()
       {
       exp = new BitAndAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "^="   exp2=expression()
       {
       exp = new ExclusiveOrAssignExpression(pre, exp2, _range(pre, exp2));
     }
     | "|="   exp2=expression()
       {
       exp = new BitOrAssignExpression(pre, exp2, _range(pre, exp2));
     }
     )
     {
       if (!(pre instanceof LeftHandSide)) {
         throw new ParseError(reader.getMessage("left.expression.in.assignment",
                                                null),
                              pre.getSourceInfo());
       }
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalExpression() :
  {
    Expression exp;
    Expression exp2;
    Expression exp3;
  }
  {
    exp=conditionalOrExpression()
      [ "?" exp2=expression() ":" exp3=conditionalExpression()
         {
      exp = new ConditionalExpression(exp, exp2, exp3, _range(exp, exp3));
    }
       ]
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=conditionalAndExpression()
      ( "||" exp2=conditionalAndExpression()
         {
      exp = new OrExpression(exp, exp2, _range(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression conditionalAndExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=inclusiveOrExpression()
      ( "&&" exp2=inclusiveOrExpression()
         {
      exp = new AndExpression(exp, exp2, _range(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression inclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=exclusiveOrExpression()
      ( "|" exp2=exclusiveOrExpression()
         {
      exp = new BitOrExpression(exp, exp2, _range(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression exclusiveOrExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=andExpression()
      ( "^" exp2=andExpression()
         { exp = new ExclusiveOrExpression(exp, exp2, _range(exp, exp2)); }
      )*
    { return exp; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression andExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=equalityExpression()
      ( "&" exp2=equalityExpression()
         {
      exp = new BitAndExpression(exp, exp2, _range(exp, exp2));
    }
    )*
    {
      return exp;
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression equalityExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=instanceOfExpression()
      ( "==" exp2=instanceOfExpression()
         {
      exp = new EqualExpression(exp, exp2, _range(exp, exp2));
    }
       | "!=" exp2=instanceOfExpression()
         {
         exp = new NotEqualExpression(exp, exp2, _range(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression instanceOfExpression() :
  {
    Expression exp;
    TypeName       typ = null;
  }
  {
    exp=relationalExpression() [ "instanceof" typ=type() ]
    {
      if (typ != null) { return new InstanceOfExpression(exp, typ, _range(exp, typ)); }
      else { return exp; }
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression relationalExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=shiftExpression()
      ( LOOKAHEAD(1) ( // consume as large an expression as possible
        "<"  exp2=shiftExpression()
         {
            exp = new LessExpression(exp, exp2, _range(exp, exp2));
         }
       | ">"  exp2=shiftExpression()
         {
         exp = new GreaterExpression(exp, exp2, _range(exp, exp2));
         }
       | "<=" exp2=shiftExpression()
         {
         exp = new LessOrEqualExpression(exp, exp2, _range(exp, exp2));
         }
       | ">=" exp2=shiftExpression()
         {
         exp = new GreaterOrEqualExpression(exp, exp2, _range(exp, exp2));
         }
       ))*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression shiftExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=additiveExpression()
      ( "<<"  exp2=additiveExpression()
         {
      exp = new ShiftLeftExpression(exp, exp2, _range(exp, exp2));
    }
       | <RSSHIFT1> <RSSHIFT2>  exp2=additiveExpression()
         {
         exp = new ShiftRightExpression(exp, exp2, _range(exp, exp2));
       }
       | <RUSHIFT1> <RUSHIFT2> <RUSHIFT3> exp2=additiveExpression()
         {
         exp = new UnsignedShiftRightExpression(exp, exp2, _range(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression additiveExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=multiplicativeExpression()
      ( LOOKAHEAD(1) (// consume as large an expression as possible
        "+" exp2=multiplicativeExpression()
         {
           exp = new AddExpression(exp, exp2, _range(exp, exp2));
         }
       | "-" exp2=multiplicativeExpression()
         {
           exp = new SubtractExpression(exp, exp2, _range(exp, exp2));
         }
       ))*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression multiplicativeExpression() :
  {
    Expression exp;
    Expression exp2;
  }
  {
    exp=unaryExpression()
      ( "*" exp2=unaryExpression()
         {
      exp = new MultiplyExpression(exp, exp2, _range(exp, exp2));
    }
       | "/" exp2=unaryExpression()
         {
         exp = new DivideExpression(exp, exp2, _range(exp, exp2));
       }
       | "%" exp2=unaryExpression()
         {
         exp = new RemainderExpression(exp, exp2, _range(exp, exp2));
       }
       )*
       {
         return exp;
       }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpression() :
  {
    Expression exp = null;
    Token      t,tk;
  }
  {
    (
      t="+" exp=unaryExpression()
        { return new PlusExpression(exp, _range(t, exp)); }
    |
      t="-" (LOOKAHEAD(1)tk=<INTEGER_LITERAL>
             {
               try { return new IntegerLiteral("-"+tk.image, _range(t, tk)); }
               catch (NumberFormatException e) { throw new ParseError(e, _range(t, tk)); }
             }
           | LOOKAHEAD(1)tk=<LONG_LITERAL>
             {
               if(tk.image.endsWith("L")) tk.image=tk.image.substring(0,tk.image.length()-1);
               try { return new LongLiteral("-"+tk.image, _range(t, tk)); }
               catch (NumberFormatException e) { throw new ParseError(e, _range(t, tk)); } 
             }
           | exp=unaryExpression(){
               return new MinusExpression(exp, _range(t, exp));
             }
           )
    |
      exp=preIncrementExpression()
    |
      exp=preDecrementExpression()
    |
      exp=unaryExpressionNotPlusMinus()
    )
    { return exp; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression unaryExpressionNotPlusMinus() :
  {
    Expression exp;
    Token      t;
  }
  {
    ( t="~" exp=unaryExpression()
       {
      return new ComplementExpression(exp, _range(t, exp));
    }
     |
     t="!" exp=unaryExpression()
       {
       return new NotExpression(exp, _range(t, exp));
     }
     |
     LOOKAHEAD( castLookahead() )
       exp=castExpression()
       |
     exp=postfixExpression() )
     {
       return exp;
     }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression castExpression() :
  { TypeName typ; Token t; Expression exp; }
  {
    t="("
    ( LOOKAHEAD(2) typ=primitiveType() ")" exp=unaryExpression()
    | typ=type() ")" exp=unaryExpressionNotPlusMinus()
    )
    { return new CastExpression(typ, exp, _range(t, exp)); }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preIncrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="++" pe=primaryExpression()
    {
      return new PreIncrement(pe, _range(t, pe));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression preDecrementExpression() :
  {
    Expression pe;
    Token      t;
  }
  {
    t="--" pe=primaryExpression()
    {
      return new PreDecrement(pe, _range(t, pe));
    }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression postfixExpression() :
  {
    Expression pe;
  }
  {
    pe=primaryExpression()
      [ LOOKAHEAD(1) (// consume as large an expression as possible
        "++"
         {
           return new PostIncrement(pe, _range(pe, token));
         }
       | "--"
         {
         return new PostDecrement(pe, _range(pe, token));
       }
       )]
       { return pe; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression primaryExpression() :
  {
    Primary p; Option<List<TypeName>> targs; List<TypeName> targs2;
    Expression exp; List<Expression> args; List<Node> nodes;
  }
  {
    p = primaryPrefix()
    (
      LOOKAHEAD( "." | "[" | "(" | "{" | typeArguments() ("." | "(") )
      // Consume as much as possible: non-strict expression statements aren't forced to end in ";",
      // leading the analyzer to see an ambiguity between two juxtaposed expression statements and a single
      // primary.  (There is no real ambiguity, because ";" can only be elided at the end of a sequence,
      // but the parser isn't structured in a way that the analyzer can see that.)
      // There's also an ambiguity between comparison operators and type arguments, resolved by checking
      // for a dot or paren after a possible type argument list.
      (
        "."
          ( targs=optionalTypeArguments()
            ( <IDENTIFIER> { p = p.dotId(targs, token); }
            | "this" { p = p.dotThis(targs, token); }
            | "super" { p = p.dotSuper(targs, token); }
            | "new" <IDENTIFIER> { p = p.dotNew(targs, token); }
            )
          | "class" { p = p.dotClass(token); }
          )
      |
        "["
          ( "]" { p = p.withArrayDim(token); }
          | exp=expression() "]" { p = p.withArrayAccess(exp, token); }
          )
      |
        targs2=typeArguments()
          { p = p.withTypeArgs(targs2, token); }
      |
        args=arguments() { p = p.withArgs(args, token); }
      |
        nodes=classBody() { p = p.withClassBody(nodes, token); }
      )
    )*
    { return p.asExpression(); }
  }
  
  /**
   * Used internally to parse an expression
   */
  Primary primaryPrefix() :
  { Token first=getToken(1); Expression exp; PrimitiveTypeName pt; List<TypeName> targs; Primary p; }
  {
    <IDENTIFIER> { return new AmbiguousNamePrimary(token); }
  | exp=literal() { return new ExpressionPrimary(exp); }
  | "(" exp=expression() ")" { exp.setSourceInfo(_range(first, token)); return new ExpressionPrimary(exp); }
  | pt=primitiveType() { return new PrimitiveTypeNamePrimary(pt); }
  | "void" { return new VoidTypeNamePrimary(new VoidTypeName(_range(token, token))); }
  | "this" { return new ThisExpressionPrimary(token); }
  | "super" { return new PartialSuperPrimary(token); }
  | targs=typeArguments()
      ( <IDENTIFIER> { return new PartialSimpleMethodCallPrimary(Option.some(targs), token, _range(first, token)); }
      | "this" { return new PartialThisConstructorCallPrimary(Option.some(targs), _range(first, token)); }
      | "super" { return new PartialSuperConstructorCallPrimary(Option.some(targs), _range(first, token)); }
      )
  | p=allocation() { return p; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Primary allocation() :
  { 
    Token first; ArrayAllocation.TypeDescriptor td; TypeName primT; ReferenceTypeName refT;
    List<TypeName> typeArgs;
  }
  { first="new"
    (
      primT=primitiveType() td=arrayDimsAndInits()
        { return new ArrayAllocationPrimary(new ArrayAllocation(primT, td, _range(first, td))); }
    |
      typeArgs=typeArguments() refT=referenceTypeName()
        { return new PartialSimpleAllocationPrimary(Option.some(typeArgs), refT, _range(first, refT)); }
    |
      refT=referenceTypeName()
      ( LOOKAHEAD(1) td=arrayDimsAndInits() // consume dims if available
          { return new ArrayAllocationPrimary(new ArrayAllocation(refT, td, _range(first, td))); }
      | { return new PartialSimpleAllocationPrimary(Option.<List<TypeName>>none(), refT, _range(first, refT)); }
      )
    )
  } 
    
  /**
   * Used internally to parse an expression
   */
  ArrayAllocation.TypeDescriptor arrayDimsAndInits() :
  {
    List<Expression>  dims = new LinkedList<Expression>();
    int   dim  = 0;
    Token left, right;
    Expression exp;
    ArrayInitializer ai;
  }
  {
    ( LOOKAHEAD(2)
       ( LOOKAHEAD(2)
          left="[" exp=expression() right="]"
          { dims.add(exp); }
        )+
        ( LOOKAHEAD(2) left="[" right="]" { dim++; } )*
       {
         return new ArrayAllocation.TypeDescriptor(dims, dim+dims.size(), null, _range(left, right));
       }
    |
       ( left = "[" "]" { dim++; } )+
       ai=arrayInitializer()
         {
           return new ArrayAllocation.TypeDescriptor(dims, dim, ai, _range(left, ai));
         }
    )
  }
  
  /**
   * Used internally to parse an expression
   */
  List<Expression> arguments() :
  { List<Expression> list = new LinkedList<Expression>(); Expression exp; }
  {
    "("
      [ exp=expression() { list.add(exp); }
        ( "," exp=expression() { list.add(exp); } )*
      ]
      ")"
      { return list; }
  }
  
  /**
   * Used internally to parse an expression
   */
  Expression literal() :
  {
    Token t;
  }
  {
    try {
      t=<INTEGER_LITERAL>
      {
        try { return new IntegerLiteral(t.image, _range(t, t)); }
        catch (NumberFormatException e) { throw new ParseError(e, _range(t, t)); }
      }
      |
        t=<LONG_LITERAL>
      {
        if(t.image.endsWith("L")) t.image=t.image.substring(0,t.image.length()-1);
        try { return new LongLiteral(t.image, _range(t, t)); }
        catch (NumberFormatException e) { throw new ParseError(e, _range(t, t)); }
      }
      |
        t=<FLOAT_LITERAL>
      {
        return new FloatLiteral(t.image, _range(t, t));
      }
      |
        t=<DOUBLE_LITERAL>
      {
        return new DoubleLiteral(t.image, _range(t, t));
      }
      |
        t=<CHARACTER_LITERAL>
      {
        return new CharacterLiteral(t.image, _range(t, t));
      }
      |
        t=<STRING_LITERAL>
      {
        return new StringLiteral(t.image, _range(t, t));
      }
      |
        t="true"
      {
        return new BooleanLiteral(true, _range(t, t));
      }
      |
        t="false"
      {
        return new BooleanLiteral(false, _range(t, t));
      }
      |
        t="null"
      {
        return new NullLiteral(_range(t, t));
      }
    }
    catch (ParseException pe) {
      _throwParseException(pe, "This is an illegal literal!");
    }
  }

  
  // Productions for Types ///////////////////////////////////////////////////////////
  
  /**
   * Used internally to parse types
   */
  TypeName type() :
  {
    int   dim = 0;
    TypeName  pt  = null;
    Token t   = null;
    TypeName rt = null;
  }
  {
    ( pt=primitiveType()
       | rt=referenceTypeName()
       )
      ( "[" t="]"
         {
      dim++;
    }
    )*
    {
      if (pt != null) {
        rt = pt;
      }
      if (dim == 0) {
        return rt;
      } else {
        return new ArrayTypeName(rt, dim, false, _range(rt, t));
      }
    }
  }
  
  /**
   * Used internally to parse types
   */
  TypeName resultType() :
  {
    TypeName  typ;
    Token t;
  }
  {
    t="void"
    {
      return new VoidTypeName(_range(t, t));
    }
    |
      typ=type()
    {
      return typ;
    }
  }
  
  /**
   * Used internally to parse types
   */
  PrimitiveTypeName primitiveType() :
  {
    Token t;
  }
  {
    t="boolean"
    {
      return new BooleanTypeName(_range(t, t));
    }
    |
      t="char"
    {
      return new CharTypeName(_range(t, t));
    }
    |
      t="byte"
    {
      return new ByteTypeName(_range(t, t));
    }
    |
      t="short"
    {
      return new ShortTypeName(_range(t, t));
    }
    |
      t="int"
    {
      return new IntTypeName(_range(t, t));
    }
    |
      t="long"
    {
      return new LongTypeName(_range(t, t));
    }
    |
      t="float"
    {
      return new FloatTypeName(_range(t, t));
    }
    |
      t="double"
    {
      return new DoubleTypeName(_range(t, t));
    }
  }
  
  TypeParameter[] typeParameters() :
  {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
  }
  {
    <LESS>
      temp = typeParameter() { list.add(temp); }
    (
     <COMMA>
     temp = typeParameter() { list.add(temp); }
    )*
      RightAngledBracket()
    { return list.toArray(new TypeParameter[0]); }
  }
  
  TypeParameter typeParameter() :
  {
    List<IdentifierToken> name;
    TypeName bound = new ReferenceTypeName("java.lang.Object");
    List<ReferenceTypeName> interfaceBoundsList = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName interf;
  }
  {
    name = name()
      [
       "extends"
         bound = type()
         ("&" interf = referenceTypeName()
            { interfaceBoundsList.add(interf); }
         )*
       ]
    {
      IdentifierToken first = name.get(0);
      if(bound instanceof ReferenceTypeName){
        return new TypeParameter(name, (ReferenceTypeName)bound, interfaceBoundsList, _range(name.get(0), token));
      } else {
        throw new ParseError("Primitives are not allowed as bound"+
                              "types, and array types are temporarily disabled due to a "+
                              "DynamicJava AST hierarchy bug!", first.getSourceInfo());
      }
    }
  }
  
  Option<List<TypeName>> optionalTypeArguments() :
  { List<TypeName> targs = null; }
  {
    [ targs=typeArguments() ] { return Option.wrap(targs); }
  }
  
  List<TypeName> typeArguments() :
  {
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    TypeName arg;
  }
  {
    <LESS>
    arg = TypeArgument() { typeArgs.add(arg); }
    ( <COMMA> arg = TypeArgument() { typeArgs.add(arg); } )*
    RightAngledBracket() { return typeArgs; }
  }
  
  TypeName TypeArgument() :
  { Token hook; TypeName upper = null; TypeName lower = null; }
  {
    (
      hook="?" ( "extends" upper = type() )? ( "super" lower = type() )?
      { return new HookTypeName(Option.wrap(upper), Option.wrap(lower), _range(hook, token)); }
    | upper = type() { return upper; }
    )
  }
  
  Token RightAngledBracket() :
  {
    Token t;
  }
  {
    ( t=<GREATER_THAN> | t=<RSSHIFT1> | t=<RSSHIFT2> | t=<RUSHIFT1> | t=<RUSHIFT2> | t=<RUSHIFT3> )
    { return t; }
  }
  
    
  // Productions for Annotations /////////////////////////////////////////////////////
  
  Annotation annotation() :
  {
    Token first;
    ReferenceTypeName type;
    Token id;
    Expression exp;
    List<Pair<String, Expression>> vals = new LinkedList<Pair<String, Expression>>();
  }
  {
    first="@" type=referenceTypeName()
    [
      "("
      (
        LOOKAHEAD(2) id=<IDENTIFIER> "=" exp=annotationValue() { vals.add(Pair.make(id.image, exp)); }
          ( "," id=<IDENTIFIER> "=" exp=annotationValue() { vals.add(Pair.make(id.image, exp)); } )*
      |
        exp=annotationValue() { vals.add(Pair.make("value", exp)); }
      )
      ")"
    ]
    { return new Annotation(type, vals, _range(first, token)); }
  }
  
  Expression annotationValue() :
  { Expression exp; }
  {
    exp=conditionalExpression() { return exp; }
  | exp=annotation() { return exp; }
  | exp=annotationArrayValue() { return exp; }
  }
  
  ArrayInitializer annotationArrayValue() :
  { Token first; Expression val; List<Expression> vals = new LinkedList<Expression>(); }
  {
    first="{"
    [
      val=annotationValue() { vals.add(val); }
      ( LOOKAHEAD(2) "," val=annotationValue() { vals.add(val); } )*
    ]
    [ "," ]
    "}"
    { return new ArrayInitializer(vals, _range(first, token)); }
  }


  // Lookahead productions ////////////////////////////////////////////////////////
  
  /** Distinguish a cast expression from a parenthesized expression. */
  void castLookahead() :
  {}
  {
    "("
    ( LOOKAHEAD(1) primitiveType() // if it's a primitive, we're done
    | type() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | literal() )
    )
  }
  
  /** Distinguish an unmodified constructor declaration from other declarations. */
  void constructorLookahead() :
  {}
  { [ typeParameters() ] <IDENTIFIER> "(" }
  
  /** Distinguish an unmodified method declaration from other declarations. */
  void methodLookahead() :
  {}
  { [ typeParameters() ] resultType() <IDENTIFIER> "(" }
  
  /** Distinguish an unmodified variable or field declaration from other declarations. */
  void variableLookahead() :
  {}
  { type() <IDENTIFIER> ( "[" | "=" | "," | ";" | "}" | <EOF>) }
  
