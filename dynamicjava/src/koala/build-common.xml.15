<!--
  $Header$

  Common build-file targets for multiple projects.

  Assumes these variables are set:
    built
    srcroot
    projpath
    public_javadoc_dir

  Assumes these targets exist:
    stable
    development
 
-->
<!-- <taskdef name="javamake" classname="com.sun.tools.javamake.ant.JavaMake"/>  -->

<property name="build.sysclasspath" value="last" />

<property name="lib_dir" value="${srcroot}/edu/rice/cs/lib" />

<property name="jsr14_classpath" value="${lib_dir}/jsr14.jar" />
<property name="jsr14_collect_classpath" value="${lib_dir}/collect.jar" />

<property name="jars_dir" value="/home/javaplt/public_html/drjava/builds" />

<!-- put javadoc in this directory if generating private javadoc -->
<property name="private_javadoc_dir" value="${srcroot}/../javadoc/${ant.project.name}" />

<!-- put documentation output in this directory -->
<property name="doc_dir" value="${srcroot}/../docs" />

<!-- put Clover HTML test coverage output in this directory -->
<property name="clover_dir" value="${srcroot}/../clover" />

<!-- put Clover test coverage database files in this directory -->
<property name="clover_db_dir" value="${srcroot}/../cloverdb" />


<!-- classpath to use everywhere. -->
<path id="classpath">
  <pathelement location="${jsr14_classpath}" />
<!--  <pathelement path="${java.class.path}" /> -->
  <fileset dir="${lib_dir}">
    <include name="*.jar" />
  </fileset>
  <pathelement path="${built}" />
</path>

<target name="compile-tstamp-gmt">
  <javac srcdir="${srcroot}"
         includes="edu/rice/cs/util/ant/TstampGMT.java"
         destdir="${built}"
         bootclasspath="${jsr14_classpath}:${jsr14_collect_classpath}:${sun.boot.class.path}"
source="1.5"         
target="jsr14"
         fork="on"
         debug="on"
         optimize="off">
    <!--compilerarg value="-J-Xbootclasspath/p:${jsr14_classpath}"/-->
  </javac>
</target>

<!-- Init target. All others depend on it. Initialize the directory. -->
<target name="init">
 <!-- <available type="file" file="${jsr14_classpath}" property="jsr14_ok" />
  <antcall target="check_for_jsr14" /> -->
  <antcall target="compile-tstamp-gmt"/>
  <taskdef name="tstamp_gmt" classname="edu.rice.cs.util.ant.TstampGMT" classpath="${built}"/>
  <tstamp_gmt /> <!-- Ant requires us to make time stamp -->
  <mkdir dir="${built}" /> <!-- Make the built directory -->

  <pathconvert refid="classpath"
               property="classpath_text"
               pathsep="${path.separator}" />

</target>

<target name="check_for_jsr14" unless="jsr14_ok">
  <fail message=" JSR-14 prototype compiler was not found. A jar file containing the compiler must be put in ${lib_dir}/jsr14.jar. (We can not distribute the jar for licensing reasons.) To download jsr14, go to http://developer.java.sun.com/developer/earlyAccess/adding_generics. Then unzip the file you downloaded, and move the included javac.jar (or gjc-rt.jar) to lib/jsr14.jar." />
</target>

<!-- Reconcile source with CVS archive -->
<target name="update" depends="init">
  <cvs command="update -d -P" />
</target>

<target name="make-version-stamp">
  <tstamp_gmt /> <!-- get new time stamp to use for CVS tag -->

  <!-- Create new Version.java, filling in date and time. -->
  <filter token="DATE" value="${DSTAMP}" />
  <filter token="TIME" value="${TSTAMP}" />
  <copy file="Version.orig"
        tofile="Version.java" 
        overwrite="yes"
        filtering="yes" />
</target>



<!-- Commit source to CVS archive
     Before doing do, we update our copy with the CVS copy. This ensures that
     if there were any clashes, we have to resolve them now. Then we
     recompile (from scratch) and retest. If this all succeeds, we can commit.

     After committing, we tag the build we just made with the tag
     projectname-date-time.
-->
<target name="do-commit" depends="clean, update, test, make-version-stamp">
  <property name="version-tag"
            value="${ant.project.name}-${DSTAMP}-${TSTAMP}" />

  <!-- recompile to make new version number get into code. -->
  <echo message="All tests passed. Rebuilding to put version tag (${version-tag}) into the code." />
  <antcall target="compile" />

  <!-- Copy the dynamicjava.jar to the lib directory and commit it. -->
  <copy file="${jarfile}"
          tofile="${lib_dir}/dynamicjava.jar"
          overwrite="yes"/>
  <echo message="Copied current dynamicjava.jar to the lib directory. Please commit it to keep DrJava in sync with the koala code base." />
  
  <tempfile property="commit-comments-filename" 
            destdir="${java.io.tmpdir}"
            prefix="commit-comments" />
  <antcall target="create-commit-comments">
    <param name="commit-comments-filename" value="${commit-comments-filename}"/>
  </antcall>
  <cvs>
    <commandline>
      <argument value="commit" />
      <argument value="-F" />
      <argument value="${commit-comments-filename}" />
    </commandline>
  </cvs>
  <delete file="${commit-comments-filename}"/>

  <cvs command="tag -c ${version-tag}" quiet="true" />

  <echo message="New version ${version-tag} committed to CVS." />
  <echo message="Note: This version has not yet been released. To release it, follow the process described at http://sourceforge.net/docman/display_doc.php?docid=9899&amp;group_id=44253." />

</target>


<!-- This target saves the commit comments to the file specified in the
     "commit-comments-filename" property, which must be passed in.  The
     comments can either be typed manually on one line, or copied from an
     existing file; the user is given a choice of which method to use.

     This target uses "file-commit-comments" and "type-commit-comments" to 
     finish the task.
     
     (See the do-commit target above for how to use this file in a cvs commit.)
-->
<target name="create-commit-comments">
  <input message="Commit Comments: [t]ype manually or [r]ead from a file? "
         validargs="t,r"
         addproperty="commit-comments-method" />
  <condition property="commit-comments-readFile">
    <equals arg1="r" arg2="${commit-comments-method}"/>
  </condition>

  <!-- call both, but only one will run -->
  <antcall target="file-commit-comments">
    <param name="commit-comments-filename" value="${commit-comments-filename}"/>
  </antcall>
  <antcall target="type-commit-comments">
    <param name="commit-comments-filename" value="${commit-comments-filename}"/>
  </antcall>
</target>

<!-- Read in the name of the file containing the commit comments
     and copy its contents to our commit-comments-file.
-->
<target name="file-commit-comments" if="commit-comments-readFile">
  <input message="Name of file with commit comments:"
         addproperty="user-comments-filename"/>
  <copy file="${user-comments-filename}" tofile="${commit-comments-filename}"/>
</target>

<!-- Read in comments for a CVS commit and save to our commit-comments-file,
     but only if an existing file has not already been specified.
-->
<target name="type-commit-comments" unless="commit-comments-readFile">
  <!-- Read in commit comment, then save to a temp file -->
  <input message="Please enter the comments for the commit:"
         addproperty="commit-comments-contents" />
  <echo file="${commit-comments-filename}" 
        message="${commit-comments-contents}" />
</target>
 

<!-- By default, commit uses the development version -->
<target name="commit" depends="development">
  <echo message="Committing the development version"/>
  <antcall target="do-commit" />
</target>

<target name="commit-stable" depends="stable">
  <echo message="Committing the stable version"/>
  <antcall target="do-commit" />
</target>

<!-- commit this version and then release it. -->
<target name="commit-and-release" depends="commit, release">
</target>

<!-- Compile. We have to start at srcroot and then selectively include
     just this project in order for it to realize what files have already
     been compiled (preventing needless recompilation).

     This version works with JDK 1.4.2 and JSR-14 v2.3+ as well as JDK 1.5.0.
     (Be sure to have the right version of tools.jar on your classpath.)
-->
<target name="do-compile" depends="init">
  <mkdir dir="${built}"/>
  <javac srcdir="${srcroot}"
         includes="${projpath}/**/*java"
         destdir="${built}"
         bootclasspath="${jsr14_classpath}:${jsr14_collect_classpath}:${sun.boot.class.path}" 
  classpath="${classpath_text}"
         source="1.5"
       target="jsr14"
         debug="on"
         fork="on"
         optimize="off">
    <compilerarg value="-warnunchecked"/>
    <!--compilerarg value="-J-Xbootclasspath/p:${jsr14_classpath}"/-->
  </javac>
</target>

<!-- Raw Compile. Identical to Compile with Generic Warning Checking
     disabled.
-->
<target name="checked-compile" depends="init">
  <mkdir dir="${built}"/>
  <javac srcdir="${srcroot}"
         includes="${projpath}/**/*java"
         destdir="${built}"
         bootclasspath="${jsr14_collect_classpath}:${sun.boot.class.path}" 
  classpath="${classpath_text}"
         source="1.5"
         target="jsr14"
         debug="on"
         fork="on"
         optimize="off">
    <compilerarg value="-J-Xbootclasspath/p:${jsr14_classpath}"/>
  </javac>
</target>


<!-- Now you can run a subset of tests by doing:
     ant -Dtest-spec=XXX run-tests

     Where XXX is the substring that must be in the test's file name
     in order to run it
-->
<property name="test-spec" value="" />
<target name="test-only">
  <junit printsummary="yes" haltonerror="yes" haltonfailure="yes" fork="yes">
    <classpath refid="classpath" />

    <!-- This makes JUnit display info about each test to console -->
    <formatter type="plain" usefile="no" />

    <!-- This makes JUnit run all test classes. It figures out which ones
         automatically, without needing AllTests classes.
    -->
    <batchtest>
      <!-- The root of the fileset must be where edu/ is. -->
      <fileset dir="${built}">
        <!-- Include only from projpath to only get classes in this project!
        -->
        <include name="${projpath}/**/*${test-spec}*Test.class" />
        <exclude name="**/AllTests.class" />
        <exclude name="**/Test.class" />
      </fileset>
    </batchtest>
  </junit>
</target>

<!-- Unit test, forcing recompile first -->
<target name="test" depends="compile, test-only">
</target>

<!-- generate private javadoc for current uncommitted version -->
<target name="javadoc" depends="init">
  <tstamp_gmt />
  <antcall target="generate_javadoc">
    <param name="javadoc_dir" value="${private_javadoc_dir}" />
    <param name="javadoc_title" value="${user.name}-uncommitted-${ant.project.name}-${DSTAMP}-${TSTAMP}" />
  </antcall>
</target>


<!-- Generate javadoc, removing generics references first.
     The property javadoc_dir must be set when calling this.
     The property javadoc_title must be set when calling this.
       
     If using JSR14v2_4 and Ant 1.6, we can create javadoc containing
     the generics information.  To do this, comment out the apply task 
     that runs java since we don't want to strip out generics from the 
     source, and then uncomment the lines in the blocks to copy the source 
     code (since we usually do it in the call to java) and, finally 
     uncomment the lines in the call to javadoc which set up the 
     bootclasspath, source, and JVM args.  You'll have to fudge 
     around a little bit to get the ant syntax correct.
-->
<target name="generate_javadoc" if="javadoc_dir" depends="init">
  <delete dir="${javadoc_dir}" />
  <mkdir dir="${javadoc_dir}" />

  <mkdir dir="${javadoc_dir}/src" />

  <!-- run jsr14 from jsr14.jar to make non-generic source. -->
  <!-- Comment this block out to produce javadocs with generics -->
  <apply executable="java" failonerror="yes" parallel="yes" type="file">
    <arg value="-classpath" />
    <arg value="${classpath_text}:${java.class.path}" />
    <arg value="com.sun.tools.javac.Main" />

    <arg value="-sourcepath" />
    <arg value="${srcroot}" />

    <arg value="-bootclasspath" />
    <arg value="${jsr14_collect_classpath}:${sun.boot.class.path}" />


    <!-- Generate Java source without generics -->
    <arg value="-s" />

    <arg value="-d" />
    <arg value="${javadoc_dir}/src" />
    
    <fileset dir="${srcroot}">
      <!-- get all projects within this sourceroot -->
      <exclude name="src-*/**/*.java" />
      <include name="**/*.java" />
      <!-- <include name="${projpath}/**/*.java" /> -->
    </fileset>
  </apply>

  <!-- Now we need to copy the package.htmls over to the
       directory with the non-generic sources.
       Also copy doc-files subdirectories.
  -->
  <copy todir="${javadoc_dir}/src">
    <fileset dir="${srcroot}">
      <!-- Uncomment the next two lines to produce javadocs with generics -->
      <!--exclude name="src-*/**/*.java" /-->
      <!--include name="**/*.java" /-->
      <include name="**/package.html" />
      <include name="**/doc-files/**" />
    </fileset>
  </copy>

  <javadoc sourcepath="${javadoc_dir}/src"
           destdir="${javadoc_dir}"
           packagenames="edu.rice.cs.*"
           Private="yes"
           Use="yes"
           Version="yes"
           Windowtitle="${javadoc_title}">
<!--           Bootclasspath ="${jsr14_classpath}:${jsr14_collect_classpath}:${sun.boot.class.path}"
           source="1.5"-->

    <!--arg value="-J-Xbootclasspath/p:${jsr14_classpath}"/-->
    <classpath refid="classpath" />

    <link href="http://www.junit.org/junit/javadoc/3.7" />
    <link href="http://java.sun.com/j2se/1.3/docs/api" />
    <link href="http://koala.ilog.fr/djava/javadoc" />
  </javadoc>

  <!-- delete source we generated without generics -->
  <delete dir="${javadoc_dir}/src" />
</target>

<!-- Delete all generated files (only for this project!) -->
<target name="clean">
  <delete dir="${private_javadoc_dir}" />
  <delete dir="${built}/${projpath}" />
  <delete file="${jarfile}" />
  <delete file="${osxdir}/${osxtag}.tar.gz" />
  <delete dir="${doc_dir}" />
</target>


  <!-- Target to fix JSR-14 v1.0's collect.jar to work in JDK 1.3.
       (We have to remove java.lang.String and java.util.Arrays,
        since they were somehow compiled against JDK 1.4.)  -->
  <target name="fix-collect-v1_0">
    <delete file="${jsr14_collect_classpath}.fixed" />
    <zip destfile="${jsr14_collect_classpath}.fixed">
      <zipfileset src="${jsr14_collect_classpath}" 
                  excludes="java/lang/String.class,java/util/Arrays.class" />
    </zip>
    <move file="${jsr14_collect_classpath}.fixed" 
          toFile="${jsr14_collect_classpath}"
          overwrite="true" />
  </target>

  <!-- Clover targets -->
  <taskdef resource="clovertasks"/>

  <target name="clover"
          depends="clean-clover, with.clover, clean, test, clover-report" />

  <target name="clean-clover">
    <delete dir="${clover_dir}/${ant.project.name}" />
    <delete dir="${clover_db_dir}" />
  </target>

  <target name="with.clover">
    <mkdir dir="${clover_db_dir}" />
    <clover-setup initString="${clover_db_dir}/test_coverage.db">
      <files>
        <exclude name="**/*Test.java" />
        <exclude name="**/*TestCase.java" />
        <exclude name="**/*Test$*.java" />
      </files>
    </clover-setup>
  </target>

  <target name="clover-report" depends="with.clover">
    <clover-report>
      <current outfile="${clover_dir}/${ant.project.name}" 
               title="DrJava">
        <format type="html"/>
      </current>
    </clover-report>
  </target>
